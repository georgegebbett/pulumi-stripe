# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'FileLink',
    'FileLinkData',
    'PortalConfigurationBusinessProfile',
    'PortalConfigurationFeatures',
    'PortalConfigurationFeaturesCustomerUpdate',
    'PortalConfigurationFeaturesInvoiceHistory',
    'PortalConfigurationFeaturesPaymentMethodUpdate',
    'PortalConfigurationFeaturesSubscriptionCancel',
    'PortalConfigurationFeaturesSubscriptionCancelCancellationReason',
    'PortalConfigurationFeaturesSubscriptionPause',
    'PortalConfigurationFeaturesSubscriptionUpdate',
    'PortalConfigurationFeaturesSubscriptionUpdateProduct',
    'PortalConfigurationLoginPage',
    'PriceCurrencyOption',
    'PriceCurrencyOptionCustomUnitAmount',
    'PriceCurrencyOptionTier',
    'PriceRecurring',
    'PriceTier',
    'PriceTransformQuantity',
    'PromotionCodeRestrictions',
    'ShippingRateDeliveryEstimate',
    'ShippingRateDeliveryEstimateMaximum',
    'ShippingRateDeliveryEstimateMinimum',
    'ShippingRateFixedAmount',
    'ShippingRateFixedAmountCurrencyOption',
]

@pulumi.output_type
class FileLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created: Optional[int] = None,
                 expired: Optional[bool] = None,
                 expires_at: Optional[int] = None,
                 id: Optional[str] = None,
                 livemode: Optional[bool] = None,
                 metadata: Optional[Mapping[str, str]] = None,
                 object: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param int created: String. Time at which the object was created. Measured in seconds since the Unix epoch.
        :param bool expired: Bool. Returns if the link is already expired.
        :param int expires_at: Int. The link isn’t available after this future timestamp.
        :param str id: String. Unique identifier for the object.
        :param bool livemode: Bool. Has the value `true` if the object exists in live mode or the value `false` 
               if the object exists in test mode.
        :param Mapping[str, str] metadata: Map(String). Set of key-value pairs that you can attach to an object. 
               This can be useful for storing additional information about the object in a structured format.
        :param str object: String. String representing the object’s type. Objects of the same type share the same value.
        :param str url: String. The publicly accessible URL to download the file.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if livemode is not None:
            pulumi.set(__self__, "livemode", livemode)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def created(self) -> Optional[int]:
        """
        String. Time at which the object was created. Measured in seconds since the Unix epoch.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def expired(self) -> Optional[bool]:
        """
        Bool. Returns if the link is already expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[int]:
        """
        Int. The link isn’t available after this future timestamp.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        String. Unique identifier for the object.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def livemode(self) -> Optional[bool]:
        """
        Bool. Has the value `true` if the object exists in live mode or the value `false` 
        if the object exists in test mode.
        """
        return pulumi.get(self, "livemode")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object. 
        This can be useful for storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def object(self) -> Optional[str]:
        """
        String. String representing the object’s type. Objects of the same type share the same value.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        String. The publicly accessible URL to download the file.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FileLinkData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileLinkData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileLinkData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileLinkData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create: bool,
                 expires_at: Optional[int] = None,
                 metadata: Optional[Mapping[str, str]] = None):
        """
        :param bool create: Bool. Set this to `true` to create a file link for the newly created file. 
               Creating a link is only possible when the file’s purpose is one of the following: `business_icon`, `business_logo`,
               `customer_signature`, `dispute_evidence`, `pci_document`, `tax_document_user_upload`, or `terminal_reader_splashscreen`.
        :param int expires_at: Int. The link isn’t available after this future timestamp.
        :param Mapping[str, str] metadata: Map(String). Set of key-value pairs that you can attach to an object. 
               This can be useful for storing additional information about the object in a structured format.
        """
        pulumi.set(__self__, "create", create)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def create(self) -> bool:
        """
        Bool. Set this to `true` to create a file link for the newly created file. 
        Creating a link is only possible when the file’s purpose is one of the following: `business_icon`, `business_logo`,
        `customer_signature`, `dispute_evidence`, `pci_document`, `tax_document_user_upload`, or `terminal_reader_splashscreen`.
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[int]:
        """
        Int. The link isn’t available after this future timestamp.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object. 
        This can be useful for storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class PortalConfigurationBusinessProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privacyPolicyUrl":
            suggest = "privacy_policy_url"
        elif key == "termsOfServiceUrl":
            suggest = "terms_of_service_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationBusinessProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationBusinessProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationBusinessProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headline: Optional[str] = None,
                 privacy_policy_url: Optional[str] = None,
                 terms_of_service_url: Optional[str] = None):
        """
        :param str headline: String. The messaging shown to customers in the portal.
        :param str privacy_policy_url: String. A link to the business's publicly available privacy policy.
        :param str terms_of_service_url: String. A link to the business's publicly available terms of service.
        """
        if headline is not None:
            pulumi.set(__self__, "headline", headline)
        if privacy_policy_url is not None:
            pulumi.set(__self__, "privacy_policy_url", privacy_policy_url)
        if terms_of_service_url is not None:
            pulumi.set(__self__, "terms_of_service_url", terms_of_service_url)

    @property
    @pulumi.getter
    def headline(self) -> Optional[str]:
        """
        String. The messaging shown to customers in the portal.
        """
        return pulumi.get(self, "headline")

    @property
    @pulumi.getter(name="privacyPolicyUrl")
    def privacy_policy_url(self) -> Optional[str]:
        """
        String. A link to the business's publicly available privacy policy.
        """
        return pulumi.get(self, "privacy_policy_url")

    @property
    @pulumi.getter(name="termsOfServiceUrl")
    def terms_of_service_url(self) -> Optional[str]:
        """
        String. A link to the business's publicly available terms of service.
        """
        return pulumi.get(self, "terms_of_service_url")


@pulumi.output_type
class PortalConfigurationFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerUpdate":
            suggest = "customer_update"
        elif key == "invoiceHistory":
            suggest = "invoice_history"
        elif key == "paymentMethodUpdate":
            suggest = "payment_method_update"
        elif key == "subscriptionCancel":
            suggest = "subscription_cancel"
        elif key == "subscriptionPauses":
            suggest = "subscription_pauses"
        elif key == "subscriptionUpdates":
            suggest = "subscription_updates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_update: Optional['outputs.PortalConfigurationFeaturesCustomerUpdate'] = None,
                 invoice_history: Optional['outputs.PortalConfigurationFeaturesInvoiceHistory'] = None,
                 payment_method_update: Optional['outputs.PortalConfigurationFeaturesPaymentMethodUpdate'] = None,
                 subscription_cancel: Optional['outputs.PortalConfigurationFeaturesSubscriptionCancel'] = None,
                 subscription_pauses: Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionPause']] = None,
                 subscription_updates: Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdate']] = None):
        """
        :param 'PortalConfigurationFeaturesCustomerUpdateArgs' customer_update: List(Resource). Information about updating the customer details in the portal. See Customer Update.
        :param 'PortalConfigurationFeaturesInvoiceHistoryArgs' invoice_history: List(Resource). Information about showing the billing history in the portal. See Invoice History.
        :param 'PortalConfigurationFeaturesPaymentMethodUpdateArgs' payment_method_update: List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        :param 'PortalConfigurationFeaturesSubscriptionCancelArgs' subscription_cancel: List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        :param Sequence['PortalConfigurationFeaturesSubscriptionPauseArgs'] subscription_pauses: List(Resource). Information about pausing subscriptions in the portal. See Subscription Pause.
        :param Sequence['PortalConfigurationFeaturesSubscriptionUpdateArgs'] subscription_updates: List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
        if customer_update is not None:
            pulumi.set(__self__, "customer_update", customer_update)
        if invoice_history is not None:
            pulumi.set(__self__, "invoice_history", invoice_history)
        if payment_method_update is not None:
            pulumi.set(__self__, "payment_method_update", payment_method_update)
        if subscription_cancel is not None:
            pulumi.set(__self__, "subscription_cancel", subscription_cancel)
        if subscription_pauses is not None:
            pulumi.set(__self__, "subscription_pauses", subscription_pauses)
        if subscription_updates is not None:
            pulumi.set(__self__, "subscription_updates", subscription_updates)

    @property
    @pulumi.getter(name="customerUpdate")
    def customer_update(self) -> Optional['outputs.PortalConfigurationFeaturesCustomerUpdate']:
        """
        List(Resource). Information about updating the customer details in the portal. See Customer Update.
        """
        return pulumi.get(self, "customer_update")

    @property
    @pulumi.getter(name="invoiceHistory")
    def invoice_history(self) -> Optional['outputs.PortalConfigurationFeaturesInvoiceHistory']:
        """
        List(Resource). Information about showing the billing history in the portal. See Invoice History.
        """
        return pulumi.get(self, "invoice_history")

    @property
    @pulumi.getter(name="paymentMethodUpdate")
    def payment_method_update(self) -> Optional['outputs.PortalConfigurationFeaturesPaymentMethodUpdate']:
        """
        List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        """
        return pulumi.get(self, "payment_method_update")

    @property
    @pulumi.getter(name="subscriptionCancel")
    def subscription_cancel(self) -> Optional['outputs.PortalConfigurationFeaturesSubscriptionCancel']:
        """
        List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        """
        return pulumi.get(self, "subscription_cancel")

    @property
    @pulumi.getter(name="subscriptionPauses")
    def subscription_pauses(self) -> Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionPause']]:
        """
        List(Resource). Information about pausing subscriptions in the portal. See Subscription Pause.
        """
        return pulumi.get(self, "subscription_pauses")

    @property
    @pulumi.getter(name="subscriptionUpdates")
    def subscription_updates(self) -> Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdate']]:
        """
        List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
        return pulumi.get(self, "subscription_updates")


@pulumi.output_type
class PortalConfigurationFeaturesCustomerUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedUpdates":
            suggest = "allowed_updates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesCustomerUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesCustomerUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesCustomerUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 allowed_updates: Optional[Sequence[str]] = None):
        """
        :param bool enabled: Bool. Whether the feature is enabled.
        :param Sequence[str] allowed_updates: List(String). The types of customer updates that are supported [`name`, `email`, `address`, `shipping`, `phone`, `tax_id`]. When empty, customers are not updatable.
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowed_updates is not None:
            pulumi.set(__self__, "allowed_updates", allowed_updates)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="allowedUpdates")
    def allowed_updates(self) -> Optional[Sequence[str]]:
        """
        List(String). The types of customer updates that are supported [`name`, `email`, `address`, `shipping`, `phone`, `tax_id`]. When empty, customers are not updatable.
        """
        return pulumi.get(self, "allowed_updates")


@pulumi.output_type
class PortalConfigurationFeaturesInvoiceHistory(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Bool. Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PortalConfigurationFeaturesPaymentMethodUpdate(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Bool. Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionCancel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cancellationReason":
            suggest = "cancellation_reason"
        elif key == "prorationBehavior":
            suggest = "proration_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesSubscriptionCancel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesSubscriptionCancel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesSubscriptionCancel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 cancellation_reason: Optional['outputs.PortalConfigurationFeaturesSubscriptionCancelCancellationReason'] = None,
                 mode: Optional[str] = None,
                 proration_behavior: Optional[str] = None):
        """
        :param bool enabled: Bool. Whether the feature is enabled.
        :param 'PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs' cancellation_reason: List(Resource). Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer. Details of this field is in Cancellation Reason.
        :param str mode: String. Whether to cancel subscriptions immediately or at the end of the billing period. Valid value is either `immediately` or `at_period_end`
        :param str proration_behavior: String. Whether to create prorations when canceling subscriptions. Possible values are `none` and `create_prorations`, which is only compatible with `mode=immediately`. No prorations are generated when canceling a subscription at the end of its natural billing period.
        """
        pulumi.set(__self__, "enabled", enabled)
        if cancellation_reason is not None:
            pulumi.set(__self__, "cancellation_reason", cancellation_reason)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="cancellationReason")
    def cancellation_reason(self) -> Optional['outputs.PortalConfigurationFeaturesSubscriptionCancelCancellationReason']:
        """
        List(Resource). Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer. Details of this field is in Cancellation Reason.
        """
        return pulumi.get(self, "cancellation_reason")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        String. Whether to cancel subscriptions immediately or at the end of the billing period. Valid value is either `immediately` or `at_period_end`
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[str]:
        """
        String. Whether to create prorations when canceling subscriptions. Possible values are `none` and `create_prorations`, which is only compatible with `mode=immediately`. No prorations are generated when canceling a subscription at the end of its natural billing period.
        """
        return pulumi.get(self, "proration_behavior")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionCancelCancellationReason(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 options: Sequence[str]):
        """
        :param bool enabled: Bool. Whether the feature is enabled.
        :param Sequence[str] options: List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def options(self) -> Sequence[str]:
        """
        List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionPause(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Bool. Whether the feature is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultAllowedUpdates":
            suggest = "default_allowed_updates"
        elif key == "prorationBehavior":
            suggest = "proration_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesSubscriptionUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesSubscriptionUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesSubscriptionUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_allowed_updates: Sequence[str],
                 enabled: bool,
                 products: Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdateProduct'],
                 proration_behavior: Optional[str] = None):
        """
        :param Sequence[str] default_allowed_updates: List(String). The types of subscription updates that are supported. When empty, subscriptions are not updatable. Supported values are `price`, `quantity`, and `promotion_code`.
        :param bool enabled: Bool. Whether the feature is enabled.
        :param Sequence['PortalConfigurationFeaturesSubscriptionUpdateProductArgs'] products: List(Resource). The list of products that support subscription updates. See details Products.
        :param str proration_behavior: String. Whether to create prorations when canceling subscriptions. Possible values are `none` and `create_prorations`, which is only compatible with `mode=immediately`. No prorations are generated when canceling a subscription at the end of its natural billing period.
        """
        pulumi.set(__self__, "default_allowed_updates", default_allowed_updates)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "products", products)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @property
    @pulumi.getter(name="defaultAllowedUpdates")
    def default_allowed_updates(self) -> Sequence[str]:
        """
        List(String). The types of subscription updates that are supported. When empty, subscriptions are not updatable. Supported values are `price`, `quantity`, and `promotion_code`.
        """
        return pulumi.get(self, "default_allowed_updates")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def products(self) -> Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdateProduct']:
        """
        List(Resource). The list of products that support subscription updates. See details Products.
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[str]:
        """
        String. Whether to create prorations when canceling subscriptions. Possible values are `none` and `create_prorations`, which is only compatible with `mode=immediately`. No prorations are generated when canceling a subscription at the end of its natural billing period.
        """
        return pulumi.get(self, "proration_behavior")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionUpdateProduct(dict):
    def __init__(__self__, *,
                 prices: Sequence[str],
                 product: str):
        """
        :param Sequence[str] prices: List(String). The list of price IDs for the product that a subscription can be updated to.
        :param str product: String. The product id.
        """
        pulumi.set(__self__, "prices", prices)
        pulumi.set(__self__, "product", product)

    @property
    @pulumi.getter
    def prices(self) -> Sequence[str]:
        """
        List(String). The list of price IDs for the product that a subscription can be updated to.
        """
        return pulumi.get(self, "prices")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        String. The product id.
        """
        return pulumi.get(self, "product")


@pulumi.output_type
class PortalConfigurationLoginPage(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 url: Optional[str] = None):
        """
        :param bool enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class PriceCurrencyOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customUnitAmount":
            suggest = "custom_unit_amount"
        elif key == "taxBehavior":
            suggest = "tax_behavior"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceCurrencyOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceCurrencyOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceCurrencyOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency: str,
                 custom_unit_amount: Optional['outputs.PriceCurrencyOptionCustomUnitAmount'] = None,
                 tax_behavior: Optional[str] = None,
                 tiers: Optional[Sequence['outputs.PriceCurrencyOptionTier']] = None,
                 unit_amount: Optional[int] = None,
                 unit_amount_decimal: Optional[float] = None):
        """
        :param str currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param 'PriceCurrencyOptionCustomUnitAmountArgs' custom_unit_amount: List(Resource). When set, 
               provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
               See details in custom unit amount.
        :param str tax_behavior: String. Only required if a default tax behavior was not provided in the Stripe Tax settings. 
               Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
               One of `inclusive`, `exclusive`, or `unspecified`.
               Once specified as either inclusive or exclusive, it cannot be changed.
        :param Sequence['PriceCurrencyOptionTierArgs'] tiers: List(Resource). Each element represents a pricing tier. 
               This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
               the same fields as the root tiers block
        :param int unit_amount: Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param float unit_amount_decimal: Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
               decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        pulumi.set(__self__, "currency", currency)
        if custom_unit_amount is not None:
            pulumi.set(__self__, "custom_unit_amount", custom_unit_amount)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @property
    @pulumi.getter
    def currency(self) -> str:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="customUnitAmount")
    def custom_unit_amount(self) -> Optional['outputs.PriceCurrencyOptionCustomUnitAmount']:
        """
        List(Resource). When set, 
        provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
        See details in custom unit amount.
        """
        return pulumi.get(self, "custom_unit_amount")

    @property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[str]:
        """
        String. Only required if a default tax behavior was not provided in the Stripe Tax settings. 
        Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
        One of `inclusive`, `exclusive`, or `unspecified`.
        Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behavior")

    @property
    @pulumi.getter
    def tiers(self) -> Optional[Sequence['outputs.PriceCurrencyOptionTier']]:
        """
        List(Resource). Each element represents a pricing tier. 
        This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
        the same fields as the root tiers block
        """
        return pulumi.get(self, "tiers")

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[int]:
        """
        Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[float]:
        """
        Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
        decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")


@pulumi.output_type
class PriceCurrencyOptionCustomUnitAmount(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 maximum: Optional[int] = None,
                 minimum: Optional[int] = None,
                 preset: Optional[int] = None):
        """
        :param bool enabled: Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        :param int maximum: Int. The maximum unit amount the customer can specify for this item.
        :param int minimum: Int. The minimum unit amount the customer can specify for this item. 
               Must be at least the minimum charge amount.
        :param int preset: Int. The starting unit amount which can be updated by the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[int]:
        """
        Int. The maximum unit amount the customer can specify for this item.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[int]:
        """
        Int. The minimum unit amount the customer can specify for this item. 
        Must be at least the minimum charge amount.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def preset(self) -> Optional[int]:
        """
        Int. The starting unit amount which can be updated by the customer.
        """
        return pulumi.get(self, "preset")


@pulumi.output_type
class PriceCurrencyOptionTier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flatAmount":
            suggest = "flat_amount"
        elif key == "flatAmountDecimal":
            suggest = "flat_amount_decimal"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"
        elif key == "upTo":
            suggest = "up_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceCurrencyOptionTier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceCurrencyOptionTier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceCurrencyOptionTier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flat_amount: Optional[int] = None,
                 flat_amount_decimal: Optional[float] = None,
                 unit_amount: Optional[int] = None,
                 unit_amount_decimal: Optional[float] = None,
                 up_to: Optional[int] = None):
        """
        :param int flat_amount: Int. The flat billing amount for an entire tier, regardless of the number of units in the
               tier.
        :param float flat_amount_decimal: Float. Same as `flat_amount`, but accepts a decimal value representing an integer
               in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        :param int unit_amount: Int. The per-unit billing amount for each individual unit for which this tier applies.
        :param float unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        :param int up_to: Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
               previous tier adding one. Use `-1` to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[int]:
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        return pulumi.get(self, "flat_amount")

    @property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[float]:
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[int]:
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[float]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[int]:
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
        return pulumi.get(self, "up_to")


@pulumi.output_type
class PriceRecurring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateUsage":
            suggest = "aggregate_usage"
        elif key == "intervalCount":
            suggest = "interval_count"
        elif key == "usageType":
            suggest = "usage_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceRecurring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceRecurring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceRecurring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: str,
                 aggregate_usage: Optional[str] = None,
                 interval_count: Optional[int] = None,
                 usage_type: Optional[str] = None):
        """
        :param str interval: String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        :param str aggregate_usage: String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
               Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
               record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
               which uses the usage record with the maximum reported usage during a period.
        :param int interval_count: Int. The number of intervals between subscription billings. For
               example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
               12 months, or 52 weeks).
        :param str usage_type: String. Configures how the quantity per period should be determined. Can be either `metered`
               or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
               the total usage based on usage records. Defaults to `licensed`.
        """
        pulumi.set(__self__, "interval", interval)
        if aggregate_usage is not None:
            pulumi.set(__self__, "aggregate_usage", aggregate_usage)
        if interval_count is not None:
            pulumi.set(__self__, "interval_count", interval_count)
        if usage_type is not None:
            pulumi.set(__self__, "usage_type", usage_type)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="aggregateUsage")
    def aggregate_usage(self) -> Optional[str]:
        """
        String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
        Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
        record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
        which uses the usage record with the maximum reported usage during a period.
        """
        return pulumi.get(self, "aggregate_usage")

    @property
    @pulumi.getter(name="intervalCount")
    def interval_count(self) -> Optional[int]:
        """
        Int. The number of intervals between subscription billings. For
        example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
        12 months, or 52 weeks).
        """
        return pulumi.get(self, "interval_count")

    @property
    @pulumi.getter(name="usageType")
    def usage_type(self) -> Optional[str]:
        """
        String. Configures how the quantity per period should be determined. Can be either `metered`
        or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
        the total usage based on usage records. Defaults to `licensed`.
        """
        return pulumi.get(self, "usage_type")


@pulumi.output_type
class PriceTier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flatAmount":
            suggest = "flat_amount"
        elif key == "flatAmountDecimal":
            suggest = "flat_amount_decimal"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"
        elif key == "upTo":
            suggest = "up_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceTier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceTier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceTier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flat_amount: Optional[int] = None,
                 flat_amount_decimal: Optional[float] = None,
                 unit_amount: Optional[int] = None,
                 unit_amount_decimal: Optional[float] = None,
                 up_to: Optional[int] = None):
        """
        :param int flat_amount: Int. The flat billing amount for an entire tier, regardless of the number of units in the
               tier.
        :param float flat_amount_decimal: Float. Same as `flat_amount`, but accepts a decimal value representing an integer
               in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        :param int unit_amount: Int. The per-unit billing amount for each individual unit for which this tier applies.
        :param float unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        :param int up_to: Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
               previous tier adding one. Use `-1` to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[int]:
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        return pulumi.get(self, "flat_amount")

    @property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[float]:
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[int]:
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[float]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[int]:
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
        return pulumi.get(self, "up_to")


@pulumi.output_type
class PriceTransformQuantity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "divideBy":
            suggest = "divide_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceTransformQuantity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceTransformQuantity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceTransformQuantity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 divide_by: int,
                 round: str):
        """
        :param int divide_by: Int. Divide usage by this number.
        :param str round: String. After division, either round the result `up` or `down`.
        """
        pulumi.set(__self__, "divide_by", divide_by)
        pulumi.set(__self__, "round", round)

    @property
    @pulumi.getter(name="divideBy")
    def divide_by(self) -> int:
        """
        Int. Divide usage by this number.
        """
        return pulumi.get(self, "divide_by")

    @property
    @pulumi.getter
    def round(self) -> str:
        """
        String. After division, either round the result `up` or `down`.
        """
        return pulumi.get(self, "round")


@pulumi.output_type
class PromotionCodeRestrictions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstTimeTransaction":
            suggest = "first_time_transaction"
        elif key == "minimumAmount":
            suggest = "minimum_amount"
        elif key == "minimumAmountCurrency":
            suggest = "minimum_amount_currency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromotionCodeRestrictions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromotionCodeRestrictions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromotionCodeRestrictions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 first_time_transaction: bool,
                 minimum_amount: int,
                 minimum_amount_currency: str):
        """
        :param bool first_time_transaction: Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        :param int minimum_amount: Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        :param str minimum_amount_currency: String. Three-letter ISO code for `minimum_amount`.
        """
        pulumi.set(__self__, "first_time_transaction", first_time_transaction)
        pulumi.set(__self__, "minimum_amount", minimum_amount)
        pulumi.set(__self__, "minimum_amount_currency", minimum_amount_currency)

    @property
    @pulumi.getter(name="firstTimeTransaction")
    def first_time_transaction(self) -> bool:
        """
        Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        """
        return pulumi.get(self, "first_time_transaction")

    @property
    @pulumi.getter(name="minimumAmount")
    def minimum_amount(self) -> int:
        """
        Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        """
        return pulumi.get(self, "minimum_amount")

    @property
    @pulumi.getter(name="minimumAmountCurrency")
    def minimum_amount_currency(self) -> str:
        """
        String. Three-letter ISO code for `minimum_amount`.
        """
        return pulumi.get(self, "minimum_amount_currency")


@pulumi.output_type
class ShippingRateDeliveryEstimate(dict):
    def __init__(__self__, *,
                 maximum: Optional['outputs.ShippingRateDeliveryEstimateMaximum'] = None,
                 minimum: Optional['outputs.ShippingRateDeliveryEstimateMinimum'] = None):
        """
        :param 'ShippingRateDeliveryEstimateMaximumArgs' maximum: List(Resource. The upper bound of the estimated range.
               Please see Delivery Estimate Definition.
        :param 'ShippingRateDeliveryEstimateMinimumArgs' minimum: List(Resource). The lower bound of the estimated range. 
               Please see Delivery Estimate Definition.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional['outputs.ShippingRateDeliveryEstimateMaximum']:
        """
        List(Resource. The upper bound of the estimated range.
        Please see Delivery Estimate Definition.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional['outputs.ShippingRateDeliveryEstimateMinimum']:
        """
        List(Resource). The lower bound of the estimated range. 
        Please see Delivery Estimate Definition.
        """
        return pulumi.get(self, "minimum")


@pulumi.output_type
class ShippingRateDeliveryEstimateMaximum(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: String. A unit of time. Possible values `hour`, `day`, `business_day`, `week` and `month`.
        :param int value: Int. Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        String. A unit of time. Possible values `hour`, `day`, `business_day`, `week` and `month`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Int. Must be greater than 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ShippingRateDeliveryEstimateMinimum(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: int):
        """
        :param str unit: String. A unit of time. Possible values `hour`, `day`, `business_day`, `week` and `month`.
        :param int value: Int. Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        String. A unit of time. Possible values `hour`, `day`, `business_day`, `week` and `month`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Int. Must be greater than 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ShippingRateFixedAmount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currencyOptions":
            suggest = "currency_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingRateFixedAmount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingRateFixedAmount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingRateFixedAmount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: int,
                 currency: str,
                 currency_options: Optional[Sequence['outputs.ShippingRateFixedAmountCurrencyOption']] = None):
        """
        :param int amount: Int. A non-negative integer in cents representing how much to charge.
        :param str currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param Sequence['ShippingRateFixedAmountCurrencyOptionArgs'] currency_options: List(Resource). Please see argument details Currency Option
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)

    @property
    @pulumi.getter
    def amount(self) -> int:
        """
        Int. A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def currency(self) -> str:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[Sequence['outputs.ShippingRateFixedAmountCurrencyOption']]:
        """
        List(Resource). Please see argument details Currency Option
        """
        return pulumi.get(self, "currency_options")


@pulumi.output_type
class ShippingRateFixedAmountCurrencyOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taxBehavior":
            suggest = "tax_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingRateFixedAmountCurrencyOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingRateFixedAmountCurrencyOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingRateFixedAmountCurrencyOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: int,
                 currency: str,
                 tax_behavior: Optional[str] = None):
        """
        :param int amount: Int. (Required) Int. A non-negative integer in cents representing how much to charge.
        :param str currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)

    @property
    @pulumi.getter
    def amount(self) -> int:
        """
        Int. (Required) Int. A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def currency(self) -> str:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[str]:
        return pulumi.get(self, "tax_behavior")


