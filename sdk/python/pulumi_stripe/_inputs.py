# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'FileLinkArgs',
    'FileLinkArgsDict',
    'FileLinkDataArgs',
    'FileLinkDataArgsDict',
    'MeterCustomerMappingArgs',
    'MeterCustomerMappingArgsDict',
    'MeterDefaultAggregationArgs',
    'MeterDefaultAggregationArgsDict',
    'MeterValueSettingsArgs',
    'MeterValueSettingsArgsDict',
    'PortalConfigurationBusinessProfileArgs',
    'PortalConfigurationBusinessProfileArgsDict',
    'PortalConfigurationFeaturesArgs',
    'PortalConfigurationFeaturesArgsDict',
    'PortalConfigurationFeaturesCustomerUpdateArgs',
    'PortalConfigurationFeaturesCustomerUpdateArgsDict',
    'PortalConfigurationFeaturesInvoiceHistoryArgs',
    'PortalConfigurationFeaturesInvoiceHistoryArgsDict',
    'PortalConfigurationFeaturesPaymentMethodUpdateArgs',
    'PortalConfigurationFeaturesPaymentMethodUpdateArgsDict',
    'PortalConfigurationFeaturesSubscriptionCancelArgs',
    'PortalConfigurationFeaturesSubscriptionCancelArgsDict',
    'PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs',
    'PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgsDict',
    'PortalConfigurationFeaturesSubscriptionUpdateArgs',
    'PortalConfigurationFeaturesSubscriptionUpdateArgsDict',
    'PortalConfigurationFeaturesSubscriptionUpdateProductArgs',
    'PortalConfigurationFeaturesSubscriptionUpdateProductArgsDict',
    'PortalConfigurationLoginPageArgs',
    'PortalConfigurationLoginPageArgsDict',
    'PriceCurrencyOptionArgs',
    'PriceCurrencyOptionArgsDict',
    'PriceCurrencyOptionCustomUnitAmountArgs',
    'PriceCurrencyOptionCustomUnitAmountArgsDict',
    'PriceCurrencyOptionTierArgs',
    'PriceCurrencyOptionTierArgsDict',
    'PriceCustomUnitAmountArgs',
    'PriceCustomUnitAmountArgsDict',
    'PriceRecurringArgs',
    'PriceRecurringArgsDict',
    'PriceTierArgs',
    'PriceTierArgsDict',
    'PriceTransformQuantityArgs',
    'PriceTransformQuantityArgsDict',
    'PromotionCodeRestrictionsArgs',
    'PromotionCodeRestrictionsArgsDict',
    'ShippingRateDeliveryEstimateArgs',
    'ShippingRateDeliveryEstimateArgsDict',
    'ShippingRateDeliveryEstimateMaximumArgs',
    'ShippingRateDeliveryEstimateMaximumArgsDict',
    'ShippingRateDeliveryEstimateMinimumArgs',
    'ShippingRateDeliveryEstimateMinimumArgsDict',
    'ShippingRateFixedAmountArgs',
    'ShippingRateFixedAmountArgsDict',
    'ShippingRateFixedAmountCurrencyOptionArgs',
    'ShippingRateFixedAmountCurrencyOptionArgsDict',
]

MYPY = False

if not MYPY:
    class FileLinkArgsDict(TypedDict):
        created: NotRequired[pulumi.Input[_builtins.int]]
        """
        String. Time at which the object was created. Measured in seconds since the Unix epoch.
        """
        expired: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Bool. Returns if the link is already expired.
        """
        expires_at: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. Time that the link expires.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. Unique identifier for the object.
        """
        livemode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Bool. Has the value `true` if the object exists in live mode or the value `false` 
        if the object exists in test mode.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map(String). Set of key-value pairs that you can attach to an object.
        """
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. String representing the object’s type. Objects of the same type share the same value.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. The publicly accessible URL to download the file.
        """
elif False:
    FileLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileLinkArgs:
    def __init__(__self__, *,
                 created: Optional[pulumi.Input[_builtins.int]] = None,
                 expired: Optional[pulumi.Input[_builtins.bool]] = None,
                 expires_at: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 livemode: Optional[pulumi.Input[_builtins.bool]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] created: String. Time at which the object was created. Measured in seconds since the Unix epoch.
        :param pulumi.Input[_builtins.bool] expired: Bool. Returns if the link is already expired.
        :param pulumi.Input[_builtins.int] expires_at: Int. Time that the link expires.
        :param pulumi.Input[_builtins.str] id: String. Unique identifier for the object.
        :param pulumi.Input[_builtins.bool] livemode: Bool. Has the value `true` if the object exists in live mode or the value `false` 
               if the object exists in test mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: Map(String). Set of key-value pairs that you can attach to an object.
        :param pulumi.Input[_builtins.str] object: String. String representing the object’s type. Objects of the same type share the same value.
        :param pulumi.Input[_builtins.str] url: String. The publicly accessible URL to download the file.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if livemode is not None:
            pulumi.set(__self__, "livemode", livemode)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def created(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        String. Time at which the object was created. Measured in seconds since the Unix epoch.
        """
        return pulumi.get(self, "created")

    @created.setter
    def created(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "created", value)

    @_builtins.property
    @pulumi.getter
    def expired(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Bool. Returns if the link is already expired.
        """
        return pulumi.get(self, "expired")

    @expired.setter
    def expired(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. Time that the link expires.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. Unique identifier for the object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def livemode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Bool. Has the value `true` if the object exists in live mode or the value `false` 
        if the object exists in test mode.
        """
        return pulumi.get(self, "livemode")

    @livemode.setter
    def livemode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "livemode", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. String representing the object’s type. Objects of the same type share the same value.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. The publicly accessible URL to download the file.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class FileLinkDataArgsDict(TypedDict):
        create: pulumi.Input[_builtins.bool]
        """
        Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        """
        expires_at: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. Time that the link expires.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map(String). Set of key-value pairs that you can attach to an object.
        """
elif False:
    FileLinkDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileLinkDataArgs:
    def __init__(__self__, *,
                 create: pulumi.Input[_builtins.bool],
                 expires_at: Optional[pulumi.Input[_builtins.int]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] create: Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        :param pulumi.Input[_builtins.int] expires_at: Int. Time that the link expires.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: Map(String). Set of key-value pairs that you can attach to an object.
        """
        pulumi.set(__self__, "create", create)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def create(self) -> pulumi.Input[_builtins.bool]:
        """
        Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. Time that the link expires.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class MeterCustomerMappingArgsDict(TypedDict):
        event_payload_key: pulumi.Input[_builtins.str]
        """
        String. The key in the event payload to use for customer mapping.
        """
        type: pulumi.Input[_builtins.str]
        """
        String. The method for mapping a meter event to a customer. Must be `by_id`.
        """
elif False:
    MeterCustomerMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeterCustomerMappingArgs:
    def __init__(__self__, *,
                 event_payload_key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] event_payload_key: String. The key in the event payload to use for customer mapping.
        :param pulumi.Input[_builtins.str] type: String. The method for mapping a meter event to a customer. Must be `by_id`.
        """
        pulumi.set(__self__, "event_payload_key", event_payload_key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="eventPayloadKey")
    def event_payload_key(self) -> pulumi.Input[_builtins.str]:
        """
        String. The key in the event payload to use for customer mapping.
        """
        return pulumi.get(self, "event_payload_key")

    @event_payload_key.setter
    def event_payload_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_payload_key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        String. The method for mapping a meter event to a customer. Must be `by_id`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MeterDefaultAggregationArgsDict(TypedDict):
        formula: pulumi.Input[_builtins.str]
        """
        String. Specifies how events are aggregated. Allowed values are `count` to count the number of events and `sum` to sum each event’s value.
        """
elif False:
    MeterDefaultAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeterDefaultAggregationArgs:
    def __init__(__self__, *,
                 formula: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] formula: String. Specifies how events are aggregated. Allowed values are `count` to count the number of events and `sum` to sum each event’s value.
        """
        pulumi.set(__self__, "formula", formula)

    @_builtins.property
    @pulumi.getter
    def formula(self) -> pulumi.Input[_builtins.str]:
        """
        String. Specifies how events are aggregated. Allowed values are `count` to count the number of events and `sum` to sum each event’s value.
        """
        return pulumi.get(self, "formula")

    @formula.setter
    def formula(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "formula", value)


if not MYPY:
    class MeterValueSettingsArgsDict(TypedDict):
        event_payload_key: pulumi.Input[_builtins.str]
        """
        The key in the usage event payload to use as the value for this meter. For example, if the event payload  contains usage on a bytes_used field, then set the event_payload_key to “bytes_used”
        """
elif False:
    MeterValueSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MeterValueSettingsArgs:
    def __init__(__self__, *,
                 event_payload_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] event_payload_key: The key in the usage event payload to use as the value for this meter. For example, if the event payload  contains usage on a bytes_used field, then set the event_payload_key to “bytes_used”
        """
        pulumi.set(__self__, "event_payload_key", event_payload_key)

    @_builtins.property
    @pulumi.getter(name="eventPayloadKey")
    def event_payload_key(self) -> pulumi.Input[_builtins.str]:
        """
        The key in the usage event payload to use as the value for this meter. For example, if the event payload  contains usage on a bytes_used field, then set the event_payload_key to “bytes_used”
        """
        return pulumi.get(self, "event_payload_key")

    @event_payload_key.setter
    def event_payload_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_payload_key", value)


if not MYPY:
    class PortalConfigurationBusinessProfileArgsDict(TypedDict):
        headline: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. The messaging shown to customers in the portal.
        """
        privacy_policy_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. A link to the business's publicly available privacy policy.
        """
        terms_of_service_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. A link to the business's publicly available terms of service.
        """
elif False:
    PortalConfigurationBusinessProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationBusinessProfileArgs:
    def __init__(__self__, *,
                 headline: Optional[pulumi.Input[_builtins.str]] = None,
                 privacy_policy_url: Optional[pulumi.Input[_builtins.str]] = None,
                 terms_of_service_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] headline: String. The messaging shown to customers in the portal.
        :param pulumi.Input[_builtins.str] privacy_policy_url: String. A link to the business's publicly available privacy policy.
        :param pulumi.Input[_builtins.str] terms_of_service_url: String. A link to the business's publicly available terms of service.
        """
        if headline is not None:
            pulumi.set(__self__, "headline", headline)
        if privacy_policy_url is not None:
            pulumi.set(__self__, "privacy_policy_url", privacy_policy_url)
        if terms_of_service_url is not None:
            pulumi.set(__self__, "terms_of_service_url", terms_of_service_url)

    @_builtins.property
    @pulumi.getter
    def headline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. The messaging shown to customers in the portal.
        """
        return pulumi.get(self, "headline")

    @headline.setter
    def headline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "headline", value)

    @_builtins.property
    @pulumi.getter(name="privacyPolicyUrl")
    def privacy_policy_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. A link to the business's publicly available privacy policy.
        """
        return pulumi.get(self, "privacy_policy_url")

    @privacy_policy_url.setter
    def privacy_policy_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "privacy_policy_url", value)

    @_builtins.property
    @pulumi.getter(name="termsOfServiceUrl")
    def terms_of_service_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. A link to the business's publicly available terms of service.
        """
        return pulumi.get(self, "terms_of_service_url")

    @terms_of_service_url.setter
    def terms_of_service_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "terms_of_service_url", value)


if not MYPY:
    class PortalConfigurationFeaturesArgsDict(TypedDict):
        customer_update: NotRequired[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgsDict']]
        """
        List(Resource). Information about updating the customer details in the portal. See Customer Update.
        """
        invoice_history: NotRequired[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgsDict']]
        """
        List(Resource). Information about showing the billing history in the portal. See Invoice History.
        """
        payment_method_update: NotRequired[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgsDict']]
        """
        List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        """
        subscription_cancel: NotRequired[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgsDict']]
        """
        List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        """
        subscription_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgsDict']]]]
        """
        List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
elif False:
    PortalConfigurationFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesArgs:
    def __init__(__self__, *,
                 customer_update: Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']] = None,
                 invoice_history: Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']] = None,
                 payment_method_update: Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']] = None,
                 subscription_cancel: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']] = None,
                 subscription_updates: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]] = None):
        """
        :param pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs'] customer_update: List(Resource). Information about updating the customer details in the portal. See Customer Update.
        :param pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs'] invoice_history: List(Resource). Information about showing the billing history in the portal. See Invoice History.
        :param pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs'] payment_method_update: List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        :param pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs'] subscription_cancel: List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        :param pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]] subscription_updates: List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
        if customer_update is not None:
            pulumi.set(__self__, "customer_update", customer_update)
        if invoice_history is not None:
            pulumi.set(__self__, "invoice_history", invoice_history)
        if payment_method_update is not None:
            pulumi.set(__self__, "payment_method_update", payment_method_update)
        if subscription_cancel is not None:
            pulumi.set(__self__, "subscription_cancel", subscription_cancel)
        if subscription_updates is not None:
            pulumi.set(__self__, "subscription_updates", subscription_updates)

    @_builtins.property
    @pulumi.getter(name="customerUpdate")
    def customer_update(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']]:
        """
        List(Resource). Information about updating the customer details in the portal. See Customer Update.
        """
        return pulumi.get(self, "customer_update")

    @customer_update.setter
    def customer_update(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']]):
        pulumi.set(self, "customer_update", value)

    @_builtins.property
    @pulumi.getter(name="invoiceHistory")
    def invoice_history(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']]:
        """
        List(Resource). Information about showing the billing history in the portal. See Invoice History.
        """
        return pulumi.get(self, "invoice_history")

    @invoice_history.setter
    def invoice_history(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']]):
        pulumi.set(self, "invoice_history", value)

    @_builtins.property
    @pulumi.getter(name="paymentMethodUpdate")
    def payment_method_update(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']]:
        """
        List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        """
        return pulumi.get(self, "payment_method_update")

    @payment_method_update.setter
    def payment_method_update(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']]):
        pulumi.set(self, "payment_method_update", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionCancel")
    def subscription_cancel(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']]:
        """
        List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        """
        return pulumi.get(self, "subscription_cancel")

    @subscription_cancel.setter
    def subscription_cancel(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']]):
        pulumi.set(self, "subscription_cancel", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionUpdates")
    def subscription_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]]:
        """
        List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
        return pulumi.get(self, "subscription_updates")

    @subscription_updates.setter
    def subscription_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]]):
        pulumi.set(self, "subscription_updates", value)


if not MYPY:
    class PortalConfigurationFeaturesCustomerUpdateArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the feature is enabled.
        """
        allowed_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The types of customer updates that are supported. When empty, customers are not updatable.
        """
elif False:
    PortalConfigurationFeaturesCustomerUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesCustomerUpdateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 allowed_updates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_updates: The types of customer updates that are supported. When empty, customers are not updatable.
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowed_updates is not None:
            pulumi.set(__self__, "allowed_updates", allowed_updates)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="allowedUpdates")
    def allowed_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The types of customer updates that are supported. When empty, customers are not updatable.
        """
        return pulumi.get(self, "allowed_updates")

    @allowed_updates.setter
    def allowed_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_updates", value)


if not MYPY:
    class PortalConfigurationFeaturesInvoiceHistoryArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the feature is enabled.
        """
elif False:
    PortalConfigurationFeaturesInvoiceHistoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesInvoiceHistoryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class PortalConfigurationFeaturesPaymentMethodUpdateArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the feature is enabled.
        """
elif False:
    PortalConfigurationFeaturesPaymentMethodUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesPaymentMethodUpdateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionCancelArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the feature is enabled.
        """
        cancellation_reason: NotRequired[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgsDict']]
        """
        Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to cancel subscriptions immediately or at the end of the billing period.
        """
        proration_behavior: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to create prorations when canceling subscriptions.
        """
elif False:
    PortalConfigurationFeaturesSubscriptionCancelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionCancelArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 cancellation_reason: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 proration_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the feature is enabled.
        :param pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs'] cancellation_reason: Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        :param pulumi.Input[_builtins.str] mode: Whether to cancel subscriptions immediately or at the end of the billing period.
        :param pulumi.Input[_builtins.str] proration_behavior: Whether to create prorations when canceling subscriptions.
        """
        pulumi.set(__self__, "enabled", enabled)
        if cancellation_reason is not None:
            pulumi.set(__self__, "cancellation_reason", cancellation_reason)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="cancellationReason")
    def cancellation_reason(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']]:
        """
        Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        """
        return pulumi.get(self, "cancellation_reason")

    @cancellation_reason.setter
    def cancellation_reason(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']]):
        pulumi.set(self, "cancellation_reason", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to cancel subscriptions immediately or at the end of the billing period.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to create prorations when canceling subscriptions.
        """
        return pulumi.get(self, "proration_behavior")

    @proration_behavior.setter
    def proration_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proration_behavior", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Bool. Whether the feature is enabled.
        """
        options: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
elif False:
    PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 options: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Bool. Whether the feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] options: List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionUpdateArgsDict(TypedDict):
        default_allowed_updates: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the feature is enabled.
        """
        products: pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgsDict']]]
        """
        The list of products that support subscription updates.
        """
        proration_behavior: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines how to handle prorations resulting from subscription updates
        """
elif False:
    PortalConfigurationFeaturesSubscriptionUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionUpdateArgs:
    def __init__(__self__, *,
                 default_allowed_updates: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 enabled: pulumi.Input[_builtins.bool],
                 products: pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]],
                 proration_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] default_allowed_updates: The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        :param pulumi.Input[_builtins.bool] enabled: Whether the feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]] products: The list of products that support subscription updates.
        :param pulumi.Input[_builtins.str] proration_behavior: Determines how to handle prorations resulting from subscription updates
        """
        pulumi.set(__self__, "default_allowed_updates", default_allowed_updates)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "products", products)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @_builtins.property
    @pulumi.getter(name="defaultAllowedUpdates")
    def default_allowed_updates(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        """
        return pulumi.get(self, "default_allowed_updates")

    @default_allowed_updates.setter
    def default_allowed_updates(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "default_allowed_updates", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]]:
        """
        The list of products that support subscription updates.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]]):
        pulumi.set(self, "products", value)

    @_builtins.property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines how to handle prorations resulting from subscription updates
        """
        return pulumi.get(self, "proration_behavior")

    @proration_behavior.setter
    def proration_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proration_behavior", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionUpdateProductArgsDict(TypedDict):
        prices: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List(String). The list of price IDs for the product that a subscription can be updated to.
        """
        product: pulumi.Input[_builtins.str]
        """
        String. The product id.
        """
elif False:
    PortalConfigurationFeaturesSubscriptionUpdateProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionUpdateProductArgs:
    def __init__(__self__, *,
                 prices: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 product: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prices: List(String). The list of price IDs for the product that a subscription can be updated to.
        :param pulumi.Input[_builtins.str] product: String. The product id.
        """
        pulumi.set(__self__, "prices", prices)
        pulumi.set(__self__, "product", product)

    @_builtins.property
    @pulumi.getter
    def prices(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List(String). The list of price IDs for the product that a subscription can be updated to.
        """
        return pulumi.get(self, "prices")

    @prices.setter
    def prices(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "prices", value)

    @_builtins.property
    @pulumi.getter
    def product(self) -> pulumi.Input[_builtins.str]:
        """
        String. The product id.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "product", value)


if not MYPY:
    class PortalConfigurationLoginPageArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
elif False:
    PortalConfigurationLoginPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationLoginPageArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        :param pulumi.Input[_builtins.str] url: A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PriceCurrencyOptionArgsDict(TypedDict):
        currency: pulumi.Input[_builtins.str]
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        custom_unit_amount: NotRequired[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgsDict']]
        """
        List(Resource). When set,
        provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
        See details in Custom Unit Amount.
        """
        tax_behavior: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. Only required if a default tax behavior was not provided in the Stripe Tax settings.
        Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
        One of `inclusive`, `exclusive`, or `unspecified`.
        Once specified as either inclusive or exclusive, it cannot be changed.
        """
        tiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgsDict']]]]
        """
        List(Resource). Each element represents a pricing tier.
        This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
        the same fields as the root tiers block
        """
        unit_amount: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        unit_amount_decimal: NotRequired[pulumi.Input[_builtins.float]]
        """
        Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
        decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
elif False:
    PriceCurrencyOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceCurrencyOptionArgs:
    def __init__(__self__, *,
                 currency: pulumi.Input[_builtins.str],
                 custom_unit_amount: Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']] = None,
                 tax_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]] = None,
                 unit_amount: Optional[pulumi.Input[_builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs'] custom_unit_amount: List(Resource). When set,
               provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
               See details in Custom Unit Amount.
        :param pulumi.Input[_builtins.str] tax_behavior: String. Only required if a default tax behavior was not provided in the Stripe Tax settings.
               Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
               One of `inclusive`, `exclusive`, or `unspecified`.
               Once specified as either inclusive or exclusive, it cannot be changed.
        :param pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]] tiers: List(Resource). Each element represents a pricing tier.
               This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
               the same fields as the root tiers block
        :param pulumi.Input[_builtins.int] unit_amount: Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param pulumi.Input[_builtins.float] unit_amount_decimal: Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
               decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        pulumi.set(__self__, "currency", currency)
        if custom_unit_amount is not None:
            pulumi.set(__self__, "custom_unit_amount", custom_unit_amount)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> pulumi.Input[_builtins.str]:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "currency", value)

    @_builtins.property
    @pulumi.getter(name="customUnitAmount")
    def custom_unit_amount(self) -> Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']]:
        """
        List(Resource). When set,
        provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
        See details in Custom Unit Amount.
        """
        return pulumi.get(self, "custom_unit_amount")

    @custom_unit_amount.setter
    def custom_unit_amount(self, value: Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']]):
        pulumi.set(self, "custom_unit_amount", value)

    @_builtins.property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. Only required if a default tax behavior was not provided in the Stripe Tax settings.
        Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
        One of `inclusive`, `exclusive`, or `unspecified`.
        Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behavior")

    @tax_behavior.setter
    def tax_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tax_behavior", value)

    @_builtins.property
    @pulumi.getter
    def tiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]]:
        """
        List(Resource). Each element represents a pricing tier.
        This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
        the same fields as the root tiers block
        """
        return pulumi.get(self, "tiers")

    @tiers.setter
    def tiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]]):
        pulumi.set(self, "tiers", value)

    @_builtins.property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unit_amount", value)

    @_builtins.property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
        decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "unit_amount_decimal", value)


if not MYPY:
    class PriceCurrencyOptionCustomUnitAmountArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        """
        maximum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The maximum unit amount the customer can specify for this item.
        """
        minimum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The minimum unit amount the customer can specify for this item.
        Must be at least the minimum charge amount.
        """
        preset: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The starting unit amount which can be updated by the customer.
        """
elif False:
    PriceCurrencyOptionCustomUnitAmountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceCurrencyOptionCustomUnitAmountArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 maximum: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.int]] = None,
                 preset: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        :param pulumi.Input[_builtins.int] maximum: Int. The maximum unit amount the customer can specify for this item.
        :param pulumi.Input[_builtins.int] minimum: Int. The minimum unit amount the customer can specify for this item.
               Must be at least the minimum charge amount.
        :param pulumi.Input[_builtins.int] preset: Int. The starting unit amount which can be updated by the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The maximum unit amount the customer can specify for this item.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The minimum unit amount the customer can specify for this item.
        Must be at least the minimum charge amount.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum", value)

    @_builtins.property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The starting unit amount which can be updated by the customer.
        """
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class PriceCurrencyOptionTierArgsDict(TypedDict):
        flat_amount: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        flat_amount_decimal: NotRequired[pulumi.Input[_builtins.float]]
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        unit_amount: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        unit_amount_decimal: NotRequired[pulumi.Input[_builtins.float]]
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        up_to: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
elif False:
    PriceCurrencyOptionTierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceCurrencyOptionTierArgs:
    def __init__(__self__, *,
                 flat_amount: Optional[pulumi.Input[_builtins.int]] = None,
                 flat_amount_decimal: Optional[pulumi.Input[_builtins.float]] = None,
                 unit_amount: Optional[pulumi.Input[_builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[_builtins.float]] = None,
                 up_to: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] flat_amount: Int. The flat billing amount for an entire tier, regardless of the number of units in the
               tier.
        :param pulumi.Input[_builtins.float] flat_amount_decimal: Float. Same as `flat_amount`, but accepts a decimal value representing an integer
               in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        :param pulumi.Input[_builtins.int] unit_amount: Int. The per-unit billing amount for each individual unit for which this tier applies.
        :param pulumi.Input[_builtins.float] unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        :param pulumi.Input[_builtins.int] up_to: Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
               previous tier adding one. Use `-1` to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @_builtins.property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        return pulumi.get(self, "flat_amount")

    @flat_amount.setter
    def flat_amount(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "flat_amount", value)

    @_builtins.property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @flat_amount_decimal.setter
    def flat_amount_decimal(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "flat_amount_decimal", value)

    @_builtins.property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unit_amount", value)

    @_builtins.property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "unit_amount_decimal", value)

    @_builtins.property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
        return pulumi.get(self, "up_to")

    @up_to.setter
    def up_to(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "up_to", value)


if not MYPY:
    class PriceCustomUnitAmountArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        """
        maximum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The maximum unit amount the customer can specify for this item.
        """
        minimum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The minimum unit amount the customer can specify for this item.
        Must be at least the minimum charge amount.
        """
        preset: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The starting unit amount which can be updated by the customer.
        """
elif False:
    PriceCustomUnitAmountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceCustomUnitAmountArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 maximum: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.int]] = None,
                 preset: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        :param pulumi.Input[_builtins.int] maximum: Int. The maximum unit amount the customer can specify for this item.
        :param pulumi.Input[_builtins.int] minimum: Int. The minimum unit amount the customer can specify for this item.
               Must be at least the minimum charge amount.
        :param pulumi.Input[_builtins.int] preset: Int. The starting unit amount which can be updated by the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The maximum unit amount the customer can specify for this item.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The minimum unit amount the customer can specify for this item.
        Must be at least the minimum charge amount.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum", value)

    @_builtins.property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The starting unit amount which can be updated by the customer.
        """
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class PriceRecurringArgsDict(TypedDict):
        interval: pulumi.Input[_builtins.str]
        """
        String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        """
        aggregate_usage: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
        Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
        record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
        which uses the usage record with the maximum reported usage during a period.
        """
        interval_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. This parameter is (Required) when interval value is set. The number of intervals between subscription billings. For
        example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
        12 months, or 52 weeks).
        """
        meter: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. The meter tracking the usage of a metered price.
        """
        usage_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. Configures how the quantity per period should be determined. Can be either `metered`
        or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
        the total usage based on usage records. Defaults to `licensed`.
        """
elif False:
    PriceRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceRecurringArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[_builtins.str],
                 aggregate_usage: Optional[pulumi.Input[_builtins.str]] = None,
                 interval_count: Optional[pulumi.Input[_builtins.int]] = None,
                 meter: Optional[pulumi.Input[_builtins.str]] = None,
                 usage_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interval: String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        :param pulumi.Input[_builtins.str] aggregate_usage: String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
               Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
               record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
               which uses the usage record with the maximum reported usage during a period.
        :param pulumi.Input[_builtins.int] interval_count: Int. This parameter is (Required) when interval value is set. The number of intervals between subscription billings. For
               example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
               12 months, or 52 weeks).
        :param pulumi.Input[_builtins.str] meter: String. The meter tracking the usage of a metered price.
        :param pulumi.Input[_builtins.str] usage_type: String. Configures how the quantity per period should be determined. Can be either `metered`
               or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
               the total usage based on usage records. Defaults to `licensed`.
        """
        pulumi.set(__self__, "interval", interval)
        if aggregate_usage is not None:
            pulumi.set(__self__, "aggregate_usage", aggregate_usage)
        if interval_count is not None:
            pulumi.set(__self__, "interval_count", interval_count)
        if meter is not None:
            pulumi.set(__self__, "meter", meter)
        if usage_type is not None:
            pulumi.set(__self__, "usage_type", usage_type)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> pulumi.Input[_builtins.str]:
        """
        String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="aggregateUsage")
    def aggregate_usage(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
        Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
        record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
        which uses the usage record with the maximum reported usage during a period.
        """
        return pulumi.get(self, "aggregate_usage")

    @aggregate_usage.setter
    def aggregate_usage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregate_usage", value)

    @_builtins.property
    @pulumi.getter(name="intervalCount")
    def interval_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. This parameter is (Required) when interval value is set. The number of intervals between subscription billings. For
        example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
        12 months, or 52 weeks).
        """
        return pulumi.get(self, "interval_count")

    @interval_count.setter
    def interval_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval_count", value)

    @_builtins.property
    @pulumi.getter
    def meter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. The meter tracking the usage of a metered price.
        """
        return pulumi.get(self, "meter")

    @meter.setter
    def meter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "meter", value)

    @_builtins.property
    @pulumi.getter(name="usageType")
    def usage_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. Configures how the quantity per period should be determined. Can be either `metered`
        or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
        the total usage based on usage records. Defaults to `licensed`.
        """
        return pulumi.get(self, "usage_type")

    @usage_type.setter
    def usage_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "usage_type", value)


if not MYPY:
    class PriceTierArgsDict(TypedDict):
        flat_amount: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        flat_amount_decimal: NotRequired[pulumi.Input[_builtins.float]]
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        unit_amount: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        unit_amount_decimal: NotRequired[pulumi.Input[_builtins.float]]
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        up_to: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
elif False:
    PriceTierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceTierArgs:
    def __init__(__self__, *,
                 flat_amount: Optional[pulumi.Input[_builtins.int]] = None,
                 flat_amount_decimal: Optional[pulumi.Input[_builtins.float]] = None,
                 unit_amount: Optional[pulumi.Input[_builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[_builtins.float]] = None,
                 up_to: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] flat_amount: Int. The flat billing amount for an entire tier, regardless of the number of units in the
               tier.
        :param pulumi.Input[_builtins.float] flat_amount_decimal: Float. Same as `flat_amount`, but accepts a decimal value representing an integer
               in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        :param pulumi.Input[_builtins.int] unit_amount: Int. The per-unit billing amount for each individual unit for which this tier applies.
        :param pulumi.Input[_builtins.float] unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        :param pulumi.Input[_builtins.int] up_to: Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
               previous tier adding one. Use `-1` to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @_builtins.property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        return pulumi.get(self, "flat_amount")

    @flat_amount.setter
    def flat_amount(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "flat_amount", value)

    @_builtins.property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @flat_amount_decimal.setter
    def flat_amount_decimal(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "flat_amount_decimal", value)

    @_builtins.property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unit_amount", value)

    @_builtins.property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "unit_amount_decimal", value)

    @_builtins.property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
        return pulumi.get(self, "up_to")

    @up_to.setter
    def up_to(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "up_to", value)


if not MYPY:
    class PriceTransformQuantityArgsDict(TypedDict):
        divide_by: pulumi.Input[_builtins.int]
        """
        Int. Divide usage by this number.
        """
        round: pulumi.Input[_builtins.str]
        """
        String. After division, either round the result `up` or `down`.
        """
elif False:
    PriceTransformQuantityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceTransformQuantityArgs:
    def __init__(__self__, *,
                 divide_by: pulumi.Input[_builtins.int],
                 round: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] divide_by: Int. Divide usage by this number.
        :param pulumi.Input[_builtins.str] round: String. After division, either round the result `up` or `down`.
        """
        pulumi.set(__self__, "divide_by", divide_by)
        pulumi.set(__self__, "round", round)

    @_builtins.property
    @pulumi.getter(name="divideBy")
    def divide_by(self) -> pulumi.Input[_builtins.int]:
        """
        Int. Divide usage by this number.
        """
        return pulumi.get(self, "divide_by")

    @divide_by.setter
    def divide_by(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "divide_by", value)

    @_builtins.property
    @pulumi.getter
    def round(self) -> pulumi.Input[_builtins.str]:
        """
        String. After division, either round the result `up` or `down`.
        """
        return pulumi.get(self, "round")

    @round.setter
    def round(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "round", value)


if not MYPY:
    class PromotionCodeRestrictionsArgsDict(TypedDict):
        first_time_transaction: pulumi.Input[_builtins.bool]
        """
        Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        """
        minimum_amount: NotRequired[pulumi.Input[_builtins.int]]
        """
        Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        """
        minimum_amount_currency: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. Three-letter ISO code for `minimum_amount`.
        """
elif False:
    PromotionCodeRestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromotionCodeRestrictionsArgs:
    def __init__(__self__, *,
                 first_time_transaction: pulumi.Input[_builtins.bool],
                 minimum_amount: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum_amount_currency: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] first_time_transaction: Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        :param pulumi.Input[_builtins.int] minimum_amount: Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        :param pulumi.Input[_builtins.str] minimum_amount_currency: String. Three-letter ISO code for `minimum_amount`.
        """
        pulumi.set(__self__, "first_time_transaction", first_time_transaction)
        if minimum_amount is not None:
            pulumi.set(__self__, "minimum_amount", minimum_amount)
        if minimum_amount_currency is not None:
            pulumi.set(__self__, "minimum_amount_currency", minimum_amount_currency)

    @_builtins.property
    @pulumi.getter(name="firstTimeTransaction")
    def first_time_transaction(self) -> pulumi.Input[_builtins.bool]:
        """
        Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        """
        return pulumi.get(self, "first_time_transaction")

    @first_time_transaction.setter
    def first_time_transaction(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "first_time_transaction", value)

    @_builtins.property
    @pulumi.getter(name="minimumAmount")
    def minimum_amount(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        """
        return pulumi.get(self, "minimum_amount")

    @minimum_amount.setter
    def minimum_amount(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_amount", value)

    @_builtins.property
    @pulumi.getter(name="minimumAmountCurrency")
    def minimum_amount_currency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. Three-letter ISO code for `minimum_amount`.
        """
        return pulumi.get(self, "minimum_amount_currency")

    @minimum_amount_currency.setter
    def minimum_amount_currency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "minimum_amount_currency", value)


if not MYPY:
    class ShippingRateDeliveryEstimateArgsDict(TypedDict):
        maximum: NotRequired[pulumi.Input['ShippingRateDeliveryEstimateMaximumArgsDict']]
        """
        List(Resource. The upper bound of the estimated range.
        Please see Delivery Estimate Definition.
        """
        minimum: NotRequired[pulumi.Input['ShippingRateDeliveryEstimateMinimumArgsDict']]
        """
        List(Resource). The lower bound of the estimated range. 
        Please see Delivery Estimate Definition.
        """
elif False:
    ShippingRateDeliveryEstimateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateDeliveryEstimateArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input['ShippingRateDeliveryEstimateMaximumArgs']] = None,
                 minimum: Optional[pulumi.Input['ShippingRateDeliveryEstimateMinimumArgs']] = None):
        """
        :param pulumi.Input['ShippingRateDeliveryEstimateMaximumArgs'] maximum: List(Resource. The upper bound of the estimated range.
               Please see Delivery Estimate Definition.
        :param pulumi.Input['ShippingRateDeliveryEstimateMinimumArgs'] minimum: List(Resource). The lower bound of the estimated range. 
               Please see Delivery Estimate Definition.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input['ShippingRateDeliveryEstimateMaximumArgs']]:
        """
        List(Resource. The upper bound of the estimated range.
        Please see Delivery Estimate Definition.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input['ShippingRateDeliveryEstimateMaximumArgs']]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input['ShippingRateDeliveryEstimateMinimumArgs']]:
        """
        List(Resource). The lower bound of the estimated range. 
        Please see Delivery Estimate Definition.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input['ShippingRateDeliveryEstimateMinimumArgs']]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class ShippingRateDeliveryEstimateMaximumArgsDict(TypedDict):
        unit: pulumi.Input[_builtins.str]
        """
        The upper bound of the estimated range. If empty, represents no lower bound.
        """
        value: pulumi.Input[_builtins.int]
        """
        Must be greater than 0.
        """
elif False:
    ShippingRateDeliveryEstimateMaximumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateDeliveryEstimateMaximumArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] unit: The upper bound of the estimated range. If empty, represents no lower bound.
        :param pulumi.Input[_builtins.int] value: Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        """
        The upper bound of the estimated range. If empty, represents no lower bound.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        Must be greater than 0.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ShippingRateDeliveryEstimateMinimumArgsDict(TypedDict):
        unit: pulumi.Input[_builtins.str]
        """
        The lower bound of the estimated range. If empty, represents no lower bound.
        """
        value: pulumi.Input[_builtins.int]
        """
        Must be greater than 0.
        """
elif False:
    ShippingRateDeliveryEstimateMinimumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateDeliveryEstimateMinimumArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] unit: The lower bound of the estimated range. If empty, represents no lower bound.
        :param pulumi.Input[_builtins.int] value: Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        """
        The lower bound of the estimated range. If empty, represents no lower bound.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        Must be greater than 0.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ShippingRateFixedAmountArgsDict(TypedDict):
        amount: pulumi.Input[_builtins.int]
        """
        Int. A non-negative integer in cents representing how much to charge.
        """
        currency: pulumi.Input[_builtins.str]
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        currency_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgsDict']]]]
        """
        List(Resource). Please see argument details Currency Option
        """
elif False:
    ShippingRateFixedAmountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateFixedAmountArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[_builtins.int],
                 currency: pulumi.Input[_builtins.str],
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] amount: Int. A non-negative integer in cents representing how much to charge.
        :param pulumi.Input[_builtins.str] currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgs']]] currency_options: List(Resource). Please see argument details Currency Option
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> pulumi.Input[_builtins.int]:
        """
        Int. A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "amount", value)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> pulumi.Input[_builtins.str]:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "currency", value)

    @_builtins.property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgs']]]]:
        """
        List(Resource). Please see argument details Currency Option
        """
        return pulumi.get(self, "currency_options")

    @currency_options.setter
    def currency_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgs']]]]):
        pulumi.set(self, "currency_options", value)


if not MYPY:
    class ShippingRateFixedAmountCurrencyOptionArgsDict(TypedDict):
        amount: pulumi.Input[_builtins.int]
        """
        Int. (Required) Int. A non-negative integer in cents representing how much to charge.
        """
        currency: pulumi.Input[_builtins.str]
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        tax_behavior: NotRequired[pulumi.Input[_builtins.str]]
        """
        String. Specifies whether the price is considered inclusive of taxes or exclusive of
        taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified it cannot be changed, default is `unspecified`.
        """
elif False:
    ShippingRateFixedAmountCurrencyOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateFixedAmountCurrencyOptionArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[_builtins.int],
                 currency: pulumi.Input[_builtins.str],
                 tax_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] amount: Int. (Required) Int. A non-negative integer in cents representing how much to charge.
        :param pulumi.Input[_builtins.str] currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param pulumi.Input[_builtins.str] tax_behavior: String. Specifies whether the price is considered inclusive of taxes or exclusive of
               taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified it cannot be changed, default is `unspecified`.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> pulumi.Input[_builtins.int]:
        """
        Int. (Required) Int. A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "amount", value)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> pulumi.Input[_builtins.str]:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "currency", value)

    @_builtins.property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String. Specifies whether the price is considered inclusive of taxes or exclusive of
        taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified it cannot be changed, default is `unspecified`.
        """
        return pulumi.get(self, "tax_behavior")

    @tax_behavior.setter
    def tax_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tax_behavior", value)


