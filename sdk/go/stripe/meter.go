// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package stripe

import (
	"context"
	"reflect"

	"errors"
	"github.com/georgegebbett/pulumi-stripe/sdk/go/stripe/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// With this resource, you can create a billing meter - [Stripe API billing meter documentation](https://docs.stripe.com/api/billing/meter).
//
// A billing meter is a resource that allows you to track usage of a particular event. For example, you might create a billing meter to track the number of API calls made by a particular user. You can then attach the billing meter to a price and attach the price to a subscription to charge the user for the number of API calls they make.
//
// Related guide: [Usage based billing](https://docs.stripe.com/billing/subscriptions/usage-based)
//
// > Removal of the Billing Meter isn't supported through the Stripe API.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/georgegebbett/pulumi-stripe/sdk/go/stripe"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// meter
//			_, err := stripe.NewMeter(ctx, "sampleMeter", &stripe.MeterArgs{
//				CustomerMapping: &stripe.MeterCustomerMappingArgs{
//					EventPayloadKey: pulumi.String("stripe_customer_id"),
//					Type:            pulumi.String("by_id"),
//				},
//				DefaultAggregation: &stripe.MeterDefaultAggregationArgs{
//					Formula: pulumi.String("sum"),
//				},
//				DisplayName: pulumi.String("A Sample meter"),
//				EventName:   pulumi.String("sample_meter"),
//				ValueSettings: &stripe.MeterValueSettingsArgs{
//					EventPayloadKey: pulumi.String("value"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Note on updating meters
//
// Once created, you can update the `displayName`.
//
// Other attribute edits will trigger a destroy action (archival) and creation of a new meter entry.
//
// ## Import
//
// ```sh
// $ pulumi import stripe:index/meter:Meter meter <meter_id>
// ```
type Meter struct {
	pulumi.CustomResourceState

	// Lst(Resource). Fields that specify how to map a meter event to a customer.
	CustomerMapping MeterCustomerMappingPtrOutput `pulumi:"customerMapping"`
	// List(Resource). The default settings to aggregate a meter’s events with.
	DefaultAggregation MeterDefaultAggregationOutput `pulumi:"defaultAggregation"`
	// String. The display name of the meter.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// String. The name of the meter event to record usage for. Corresponds with the `eventName` field on meter events.
	EventName pulumi.StringOutput `pulumi:"eventName"`
	// String. The time window to pre-aggregate meter events for, if any. Possible values are:
	EventTimeWindow pulumi.StringPtrOutput `pulumi:"eventTimeWindow"`
	// List(Resource). Fields that specify how to calculate a meter event’s value.
	ValueSettings MeterValueSettingsPtrOutput `pulumi:"valueSettings"`
}

// NewMeter registers a new resource with the given unique name, arguments, and options.
func NewMeter(ctx *pulumi.Context,
	name string, args *MeterArgs, opts ...pulumi.ResourceOption) (*Meter, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DefaultAggregation == nil {
		return nil, errors.New("invalid value for required argument 'DefaultAggregation'")
	}
	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.EventName == nil {
		return nil, errors.New("invalid value for required argument 'EventName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Meter
	err := ctx.RegisterResource("stripe:index/meter:Meter", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMeter gets an existing Meter resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMeter(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MeterState, opts ...pulumi.ResourceOption) (*Meter, error) {
	var resource Meter
	err := ctx.ReadResource("stripe:index/meter:Meter", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Meter resources.
type meterState struct {
	// Lst(Resource). Fields that specify how to map a meter event to a customer.
	CustomerMapping *MeterCustomerMapping `pulumi:"customerMapping"`
	// List(Resource). The default settings to aggregate a meter’s events with.
	DefaultAggregation *MeterDefaultAggregation `pulumi:"defaultAggregation"`
	// String. The display name of the meter.
	DisplayName *string `pulumi:"displayName"`
	// String. The name of the meter event to record usage for. Corresponds with the `eventName` field on meter events.
	EventName *string `pulumi:"eventName"`
	// String. The time window to pre-aggregate meter events for, if any. Possible values are:
	EventTimeWindow *string `pulumi:"eventTimeWindow"`
	// List(Resource). Fields that specify how to calculate a meter event’s value.
	ValueSettings *MeterValueSettings `pulumi:"valueSettings"`
}

type MeterState struct {
	// Lst(Resource). Fields that specify how to map a meter event to a customer.
	CustomerMapping MeterCustomerMappingPtrInput
	// List(Resource). The default settings to aggregate a meter’s events with.
	DefaultAggregation MeterDefaultAggregationPtrInput
	// String. The display name of the meter.
	DisplayName pulumi.StringPtrInput
	// String. The name of the meter event to record usage for. Corresponds with the `eventName` field on meter events.
	EventName pulumi.StringPtrInput
	// String. The time window to pre-aggregate meter events for, if any. Possible values are:
	EventTimeWindow pulumi.StringPtrInput
	// List(Resource). Fields that specify how to calculate a meter event’s value.
	ValueSettings MeterValueSettingsPtrInput
}

func (MeterState) ElementType() reflect.Type {
	return reflect.TypeOf((*meterState)(nil)).Elem()
}

type meterArgs struct {
	// Lst(Resource). Fields that specify how to map a meter event to a customer.
	CustomerMapping *MeterCustomerMapping `pulumi:"customerMapping"`
	// List(Resource). The default settings to aggregate a meter’s events with.
	DefaultAggregation MeterDefaultAggregation `pulumi:"defaultAggregation"`
	// String. The display name of the meter.
	DisplayName string `pulumi:"displayName"`
	// String. The name of the meter event to record usage for. Corresponds with the `eventName` field on meter events.
	EventName string `pulumi:"eventName"`
	// String. The time window to pre-aggregate meter events for, if any. Possible values are:
	EventTimeWindow *string `pulumi:"eventTimeWindow"`
	// List(Resource). Fields that specify how to calculate a meter event’s value.
	ValueSettings *MeterValueSettings `pulumi:"valueSettings"`
}

// The set of arguments for constructing a Meter resource.
type MeterArgs struct {
	// Lst(Resource). Fields that specify how to map a meter event to a customer.
	CustomerMapping MeterCustomerMappingPtrInput
	// List(Resource). The default settings to aggregate a meter’s events with.
	DefaultAggregation MeterDefaultAggregationInput
	// String. The display name of the meter.
	DisplayName pulumi.StringInput
	// String. The name of the meter event to record usage for. Corresponds with the `eventName` field on meter events.
	EventName pulumi.StringInput
	// String. The time window to pre-aggregate meter events for, if any. Possible values are:
	EventTimeWindow pulumi.StringPtrInput
	// List(Resource). Fields that specify how to calculate a meter event’s value.
	ValueSettings MeterValueSettingsPtrInput
}

func (MeterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*meterArgs)(nil)).Elem()
}

type MeterInput interface {
	pulumi.Input

	ToMeterOutput() MeterOutput
	ToMeterOutputWithContext(ctx context.Context) MeterOutput
}

func (*Meter) ElementType() reflect.Type {
	return reflect.TypeOf((**Meter)(nil)).Elem()
}

func (i *Meter) ToMeterOutput() MeterOutput {
	return i.ToMeterOutputWithContext(context.Background())
}

func (i *Meter) ToMeterOutputWithContext(ctx context.Context) MeterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeterOutput)
}

// MeterArrayInput is an input type that accepts MeterArray and MeterArrayOutput values.
// You can construct a concrete instance of `MeterArrayInput` via:
//
//	MeterArray{ MeterArgs{...} }
type MeterArrayInput interface {
	pulumi.Input

	ToMeterArrayOutput() MeterArrayOutput
	ToMeterArrayOutputWithContext(context.Context) MeterArrayOutput
}

type MeterArray []MeterInput

func (MeterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Meter)(nil)).Elem()
}

func (i MeterArray) ToMeterArrayOutput() MeterArrayOutput {
	return i.ToMeterArrayOutputWithContext(context.Background())
}

func (i MeterArray) ToMeterArrayOutputWithContext(ctx context.Context) MeterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeterArrayOutput)
}

// MeterMapInput is an input type that accepts MeterMap and MeterMapOutput values.
// You can construct a concrete instance of `MeterMapInput` via:
//
//	MeterMap{ "key": MeterArgs{...} }
type MeterMapInput interface {
	pulumi.Input

	ToMeterMapOutput() MeterMapOutput
	ToMeterMapOutputWithContext(context.Context) MeterMapOutput
}

type MeterMap map[string]MeterInput

func (MeterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Meter)(nil)).Elem()
}

func (i MeterMap) ToMeterMapOutput() MeterMapOutput {
	return i.ToMeterMapOutputWithContext(context.Background())
}

func (i MeterMap) ToMeterMapOutputWithContext(ctx context.Context) MeterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeterMapOutput)
}

type MeterOutput struct{ *pulumi.OutputState }

func (MeterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Meter)(nil)).Elem()
}

func (o MeterOutput) ToMeterOutput() MeterOutput {
	return o
}

func (o MeterOutput) ToMeterOutputWithContext(ctx context.Context) MeterOutput {
	return o
}

// Lst(Resource). Fields that specify how to map a meter event to a customer.
func (o MeterOutput) CustomerMapping() MeterCustomerMappingPtrOutput {
	return o.ApplyT(func(v *Meter) MeterCustomerMappingPtrOutput { return v.CustomerMapping }).(MeterCustomerMappingPtrOutput)
}

// List(Resource). The default settings to aggregate a meter’s events with.
func (o MeterOutput) DefaultAggregation() MeterDefaultAggregationOutput {
	return o.ApplyT(func(v *Meter) MeterDefaultAggregationOutput { return v.DefaultAggregation }).(MeterDefaultAggregationOutput)
}

// String. The display name of the meter.
func (o MeterOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *Meter) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// String. The name of the meter event to record usage for. Corresponds with the `eventName` field on meter events.
func (o MeterOutput) EventName() pulumi.StringOutput {
	return o.ApplyT(func(v *Meter) pulumi.StringOutput { return v.EventName }).(pulumi.StringOutput)
}

// String. The time window to pre-aggregate meter events for, if any. Possible values are:
func (o MeterOutput) EventTimeWindow() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Meter) pulumi.StringPtrOutput { return v.EventTimeWindow }).(pulumi.StringPtrOutput)
}

// List(Resource). Fields that specify how to calculate a meter event’s value.
func (o MeterOutput) ValueSettings() MeterValueSettingsPtrOutput {
	return o.ApplyT(func(v *Meter) MeterValueSettingsPtrOutput { return v.ValueSettings }).(MeterValueSettingsPtrOutput)
}

type MeterArrayOutput struct{ *pulumi.OutputState }

func (MeterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Meter)(nil)).Elem()
}

func (o MeterArrayOutput) ToMeterArrayOutput() MeterArrayOutput {
	return o
}

func (o MeterArrayOutput) ToMeterArrayOutputWithContext(ctx context.Context) MeterArrayOutput {
	return o
}

func (o MeterArrayOutput) Index(i pulumi.IntInput) MeterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Meter {
		return vs[0].([]*Meter)[vs[1].(int)]
	}).(MeterOutput)
}

type MeterMapOutput struct{ *pulumi.OutputState }

func (MeterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Meter)(nil)).Elem()
}

func (o MeterMapOutput) ToMeterMapOutput() MeterMapOutput {
	return o
}

func (o MeterMapOutput) ToMeterMapOutputWithContext(ctx context.Context) MeterMapOutput {
	return o
}

func (o MeterMapOutput) MapIndex(k pulumi.StringInput) MeterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Meter {
		return vs[0].(map[string]*Meter)[vs[1].(string)]
	}).(MeterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MeterInput)(nil)).Elem(), &Meter{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeterArrayInput)(nil)).Elem(), MeterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeterMapInput)(nil)).Elem(), MeterMap{})
	pulumi.RegisterOutputType(MeterOutput{})
	pulumi.RegisterOutputType(MeterArrayOutput{})
	pulumi.RegisterOutputType(MeterMapOutput{})
}
