# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['PriceArgs', 'Price']

@pulumi.input_type
class PriceArgs:
    def __init__(__self__, *,
                 currency: pulumi.Input[str],
                 product: pulumi.Input[str],
                 active: Optional[pulumi.Input[bool]] = None,
                 billing_scheme: Optional[pulumi.Input[str]] = None,
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]] = None,
                 lookup_key: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 nickname: Optional[pulumi.Input[str]] = None,
                 recurring: Optional[pulumi.Input['PriceRecurringArgs']] = None,
                 tax_behaviour: Optional[pulumi.Input[str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]] = None,
                 tiers_mode: Optional[pulumi.Input[str]] = None,
                 transfer_lookup_key: Optional[pulumi.Input[bool]] = None,
                 transform_quantity: Optional[pulumi.Input['PriceTransformQuantityArgs']] = None,
                 unit_amount: Optional[pulumi.Input[int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[float]] = None):
        """
        The set of arguments for constructing a Price resource.
        :param pulumi.Input[str] currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param pulumi.Input[str] product: String. The ID of the product that this price will belong to.
        :param pulumi.Input[bool] active: Bool. Whether the price can be used for new purchases. Defaults to `true`.
        :param pulumi.Input[str] billing_scheme: String. Describes how to compute the price per period. Either `per_unit` or `tiered`
               . `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per
               unit in quantity (for prices with `usage_type=licensed`), or per unit of total usage (for prices
               with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as
               defined using the `tiers` and `tiers_mode` attributes.
        :param pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]] currency_options: List(Resource). Prices defined in each available currency option. For details
               of individual arguments see Currency Options.
        :param pulumi.Input[str] lookup_key: String. A lookup key used to retrieve prices dynamically from a static string.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
               storing additional information about the object in a structured format.
        :param pulumi.Input[str] nickname: String. A brief description of the price, hidden from customers.
        :param pulumi.Input['PriceRecurringArgs'] recurring: List(Resource). The recurring components of a price such as `interval` and `usage_type`. For
               details of individual arguments see Recurring.
        :param pulumi.Input[str] tax_behaviour: String. Specifies whether the price is considered inclusive of taxes or exclusive of
               taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it
               cannot be changed, default is `unspecified`.
        :param pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]] tiers: List(Resource). Each element represents a pricing tier. This parameter requires `billing_scheme`
               to be set to `tiered`. See also the documentation for `billing_scheme`. For details of individual arguments
               see Tiers.
        :param pulumi.Input[str] tiers_mode: String. Defines if the tiering price should be `graduated`
               or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per-unit price,
               in `graduated` tiering pricing can successively change as the quantity grows.
        :param pulumi.Input[bool] transfer_lookup_key: Bool. If set to `true`, will atomically remove the lookup key from the existing
               price, and assign it to this price.
        :param pulumi.Input['PriceTransformQuantityArgs'] transform_quantity: List(Resource). Apply a transformation to the reported usage or set quantity before
               computing the billed price. Cannot be combined with `tiers`. For details of individual arguments
               see Transform Quantity.
        :param pulumi.Input[int] unit_amount: Int. A positive integer in cents (or `-1` for a free
               price) representing how much to charge.
        :param pulumi.Input[float] unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        pulumi.set(__self__, "currency", currency)
        pulumi.set(__self__, "product", product)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if billing_scheme is not None:
            pulumi.set(__self__, "billing_scheme", billing_scheme)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)
        if lookup_key is not None:
            pulumi.set(__self__, "lookup_key", lookup_key)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)
        if recurring is not None:
            pulumi.set(__self__, "recurring", recurring)
        if tax_behaviour is not None:
            pulumi.set(__self__, "tax_behaviour", tax_behaviour)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if tiers_mode is not None:
            pulumi.set(__self__, "tiers_mode", tiers_mode)
        if transfer_lookup_key is not None:
            pulumi.set(__self__, "transfer_lookup_key", transfer_lookup_key)
        if transform_quantity is not None:
            pulumi.set(__self__, "transform_quantity", transform_quantity)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @property
    @pulumi.getter
    def currency(self) -> pulumi.Input[str]:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[str]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        String. The ID of the product that this price will belong to.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool. Whether the price can be used for new purchases. Defaults to `true`.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="billingScheme")
    def billing_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        String. Describes how to compute the price per period. Either `per_unit` or `tiered`
        . `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per
        unit in quantity (for prices with `usage_type=licensed`), or per unit of total usage (for prices
        with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as
        defined using the `tiers` and `tiers_mode` attributes.
        """
        return pulumi.get(self, "billing_scheme")

    @billing_scheme.setter
    def billing_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "billing_scheme", value)

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]]:
        """
        List(Resource). Prices defined in each available currency option. For details
        of individual arguments see Currency Options.
        """
        return pulumi.get(self, "currency_options")

    @currency_options.setter
    def currency_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]]):
        pulumi.set(self, "currency_options", value)

    @property
    @pulumi.getter(name="lookupKey")
    def lookup_key(self) -> Optional[pulumi.Input[str]]:
        """
        String. A lookup key used to retrieve prices dynamically from a static string.
        """
        return pulumi.get(self, "lookup_key")

    @lookup_key.setter
    def lookup_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lookup_key", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
        storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[str]]:
        """
        String. A brief description of the price, hidden from customers.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nickname", value)

    @property
    @pulumi.getter
    def recurring(self) -> Optional[pulumi.Input['PriceRecurringArgs']]:
        """
        List(Resource). The recurring components of a price such as `interval` and `usage_type`. For
        details of individual arguments see Recurring.
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: Optional[pulumi.Input['PriceRecurringArgs']]):
        pulumi.set(self, "recurring", value)

    @property
    @pulumi.getter(name="taxBehaviour")
    def tax_behaviour(self) -> Optional[pulumi.Input[str]]:
        """
        String. Specifies whether the price is considered inclusive of taxes or exclusive of
        taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it
        cannot be changed, default is `unspecified`.
        """
        return pulumi.get(self, "tax_behaviour")

    @tax_behaviour.setter
    def tax_behaviour(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tax_behaviour", value)

    @property
    @pulumi.getter
    def tiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]]:
        """
        List(Resource). Each element represents a pricing tier. This parameter requires `billing_scheme`
        to be set to `tiered`. See also the documentation for `billing_scheme`. For details of individual arguments
        see Tiers.
        """
        return pulumi.get(self, "tiers")

    @tiers.setter
    def tiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]]):
        pulumi.set(self, "tiers", value)

    @property
    @pulumi.getter(name="tiersMode")
    def tiers_mode(self) -> Optional[pulumi.Input[str]]:
        """
        String. Defines if the tiering price should be `graduated`
        or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per-unit price,
        in `graduated` tiering pricing can successively change as the quantity grows.
        """
        return pulumi.get(self, "tiers_mode")

    @tiers_mode.setter
    def tiers_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tiers_mode", value)

    @property
    @pulumi.getter(name="transferLookupKey")
    def transfer_lookup_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool. If set to `true`, will atomically remove the lookup key from the existing
        price, and assign it to this price.
        """
        return pulumi.get(self, "transfer_lookup_key")

    @transfer_lookup_key.setter
    def transfer_lookup_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "transfer_lookup_key", value)

    @property
    @pulumi.getter(name="transformQuantity")
    def transform_quantity(self) -> Optional[pulumi.Input['PriceTransformQuantityArgs']]:
        """
        List(Resource). Apply a transformation to the reported usage or set quantity before
        computing the billed price. Cannot be combined with `tiers`. For details of individual arguments
        see Transform Quantity.
        """
        return pulumi.get(self, "transform_quantity")

    @transform_quantity.setter
    def transform_quantity(self, value: Optional[pulumi.Input['PriceTransformQuantityArgs']]):
        pulumi.set(self, "transform_quantity", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[int]]:
        """
        Int. A positive integer in cents (or `-1` for a free
        price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[float]]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unit_amount_decimal", value)


@pulumi.input_type
class _PriceState:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None,
                 billing_scheme: Optional[pulumi.Input[str]] = None,
                 currency: Optional[pulumi.Input[str]] = None,
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]] = None,
                 lookup_key: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 nickname: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 recurring: Optional[pulumi.Input['PriceRecurringArgs']] = None,
                 tax_behaviour: Optional[pulumi.Input[str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]] = None,
                 tiers_mode: Optional[pulumi.Input[str]] = None,
                 transfer_lookup_key: Optional[pulumi.Input[bool]] = None,
                 transform_quantity: Optional[pulumi.Input['PriceTransformQuantityArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unit_amount: Optional[pulumi.Input[int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[float]] = None):
        """
        Input properties used for looking up and filtering Price resources.
        :param pulumi.Input[bool] active: Bool. Whether the price can be used for new purchases. Defaults to `true`.
        :param pulumi.Input[str] billing_scheme: String. Describes how to compute the price per period. Either `per_unit` or `tiered`
               . `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per
               unit in quantity (for prices with `usage_type=licensed`), or per unit of total usage (for prices
               with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as
               defined using the `tiers` and `tiers_mode` attributes.
        :param pulumi.Input[str] currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]] currency_options: List(Resource). Prices defined in each available currency option. For details
               of individual arguments see Currency Options.
        :param pulumi.Input[str] lookup_key: String. A lookup key used to retrieve prices dynamically from a static string.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
               storing additional information about the object in a structured format.
        :param pulumi.Input[str] nickname: String. A brief description of the price, hidden from customers.
        :param pulumi.Input[str] product: String. The ID of the product that this price will belong to.
        :param pulumi.Input['PriceRecurringArgs'] recurring: List(Resource). The recurring components of a price such as `interval` and `usage_type`. For
               details of individual arguments see Recurring.
        :param pulumi.Input[str] tax_behaviour: String. Specifies whether the price is considered inclusive of taxes or exclusive of
               taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it
               cannot be changed, default is `unspecified`.
        :param pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]] tiers: List(Resource). Each element represents a pricing tier. This parameter requires `billing_scheme`
               to be set to `tiered`. See also the documentation for `billing_scheme`. For details of individual arguments
               see Tiers.
        :param pulumi.Input[str] tiers_mode: String. Defines if the tiering price should be `graduated`
               or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per-unit price,
               in `graduated` tiering pricing can successively change as the quantity grows.
        :param pulumi.Input[bool] transfer_lookup_key: Bool. If set to `true`, will atomically remove the lookup key from the existing
               price, and assign it to this price.
        :param pulumi.Input['PriceTransformQuantityArgs'] transform_quantity: List(Resource). Apply a transformation to the reported usage or set quantity before
               computing the billed price. Cannot be combined with `tiers`. For details of individual arguments
               see Transform Quantity.
        :param pulumi.Input[str] type: String. One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a
               recurring (subscription) purchase.
        :param pulumi.Input[int] unit_amount: Int. A positive integer in cents (or `-1` for a free
               price) representing how much to charge.
        :param pulumi.Input[float] unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if billing_scheme is not None:
            pulumi.set(__self__, "billing_scheme", billing_scheme)
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)
        if lookup_key is not None:
            pulumi.set(__self__, "lookup_key", lookup_key)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if recurring is not None:
            pulumi.set(__self__, "recurring", recurring)
        if tax_behaviour is not None:
            pulumi.set(__self__, "tax_behaviour", tax_behaviour)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if tiers_mode is not None:
            pulumi.set(__self__, "tiers_mode", tiers_mode)
        if transfer_lookup_key is not None:
            pulumi.set(__self__, "transfer_lookup_key", transfer_lookup_key)
        if transform_quantity is not None:
            pulumi.set(__self__, "transform_quantity", transform_quantity)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool. Whether the price can be used for new purchases. Defaults to `true`.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="billingScheme")
    def billing_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        String. Describes how to compute the price per period. Either `per_unit` or `tiered`
        . `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per
        unit in quantity (for prices with `usage_type=licensed`), or per unit of total usage (for prices
        with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as
        defined using the `tiers` and `tiers_mode` attributes.
        """
        return pulumi.get(self, "billing_scheme")

    @billing_scheme.setter
    def billing_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "billing_scheme", value)

    @property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[str]]:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]]:
        """
        List(Resource). Prices defined in each available currency option. For details
        of individual arguments see Currency Options.
        """
        return pulumi.get(self, "currency_options")

    @currency_options.setter
    def currency_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]]):
        pulumi.set(self, "currency_options", value)

    @property
    @pulumi.getter(name="lookupKey")
    def lookup_key(self) -> Optional[pulumi.Input[str]]:
        """
        String. A lookup key used to retrieve prices dynamically from a static string.
        """
        return pulumi.get(self, "lookup_key")

    @lookup_key.setter
    def lookup_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lookup_key", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
        storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[str]]:
        """
        String. A brief description of the price, hidden from customers.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nickname", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[str]]:
        """
        String. The ID of the product that this price will belong to.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def recurring(self) -> Optional[pulumi.Input['PriceRecurringArgs']]:
        """
        List(Resource). The recurring components of a price such as `interval` and `usage_type`. For
        details of individual arguments see Recurring.
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: Optional[pulumi.Input['PriceRecurringArgs']]):
        pulumi.set(self, "recurring", value)

    @property
    @pulumi.getter(name="taxBehaviour")
    def tax_behaviour(self) -> Optional[pulumi.Input[str]]:
        """
        String. Specifies whether the price is considered inclusive of taxes or exclusive of
        taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it
        cannot be changed, default is `unspecified`.
        """
        return pulumi.get(self, "tax_behaviour")

    @tax_behaviour.setter
    def tax_behaviour(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tax_behaviour", value)

    @property
    @pulumi.getter
    def tiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]]:
        """
        List(Resource). Each element represents a pricing tier. This parameter requires `billing_scheme`
        to be set to `tiered`. See also the documentation for `billing_scheme`. For details of individual arguments
        see Tiers.
        """
        return pulumi.get(self, "tiers")

    @tiers.setter
    def tiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]]):
        pulumi.set(self, "tiers", value)

    @property
    @pulumi.getter(name="tiersMode")
    def tiers_mode(self) -> Optional[pulumi.Input[str]]:
        """
        String. Defines if the tiering price should be `graduated`
        or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per-unit price,
        in `graduated` tiering pricing can successively change as the quantity grows.
        """
        return pulumi.get(self, "tiers_mode")

    @tiers_mode.setter
    def tiers_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tiers_mode", value)

    @property
    @pulumi.getter(name="transferLookupKey")
    def transfer_lookup_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool. If set to `true`, will atomically remove the lookup key from the existing
        price, and assign it to this price.
        """
        return pulumi.get(self, "transfer_lookup_key")

    @transfer_lookup_key.setter
    def transfer_lookup_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "transfer_lookup_key", value)

    @property
    @pulumi.getter(name="transformQuantity")
    def transform_quantity(self) -> Optional[pulumi.Input['PriceTransformQuantityArgs']]:
        """
        List(Resource). Apply a transformation to the reported usage or set quantity before
        computing the billed price. Cannot be combined with `tiers`. For details of individual arguments
        see Transform Quantity.
        """
        return pulumi.get(self, "transform_quantity")

    @transform_quantity.setter
    def transform_quantity(self, value: Optional[pulumi.Input['PriceTransformQuantityArgs']]):
        pulumi.set(self, "transform_quantity", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        String. One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a
        recurring (subscription) purchase.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[int]]:
        """
        Int. A positive integer in cents (or `-1` for a free
        price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[float]]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unit_amount_decimal", value)


class Price(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 active: Optional[pulumi.Input[bool]] = None,
                 billing_scheme: Optional[pulumi.Input[str]] = None,
                 currency: Optional[pulumi.Input[str]] = None,
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceCurrencyOptionArgs']]]]] = None,
                 lookup_key: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 nickname: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 recurring: Optional[pulumi.Input[pulumi.InputType['PriceRecurringArgs']]] = None,
                 tax_behaviour: Optional[pulumi.Input[str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceTierArgs']]]]] = None,
                 tiers_mode: Optional[pulumi.Input[str]] = None,
                 transfer_lookup_key: Optional[pulumi.Input[bool]] = None,
                 transform_quantity: Optional[pulumi.Input[pulumi.InputType['PriceTransformQuantityArgs']]] = None,
                 unit_amount: Optional[pulumi.Input[int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[float]] = None,
                 __props__=None):
        """
        With this resource, you can create a price - [Stripe API price documentation](https://stripe.com/docs/api/prices).

        Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of
        products. Products help you track inventory or provisioning, and prices help you track payment terms.

        Different physical goods or levels of service should be represented by products, and pricing options should be
        represented by prices. This approach lets you change prices without having to change your provisioning scheme.

        For example, you might have a single "gold" product that has prices for $10/month, $100/year, and €9 once.

        > Removal of the price isn't supported through the Stripe SDK. The best practice, which this provider follows,
        is to archive the price by marking it as inactive on destroy, which indicates that the price is no longer
        available for purchase.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_stripe as stripe

        # basic price for the product
        price_price = stripe.Price("pricePrice",
            product=stripe_product["product"]["id"],
            currency="aud",
            unit_amount=100)
        # basic free price for the product
        price_index_price_price = stripe.Price("priceIndex/pricePrice",
            product=stripe_product["product"]["id"],
            currency="aud",
            unit_amount=-1)
        # recurring price for the product
        price_stripe_index_price_price = stripe.Price("priceStripeIndex/pricePrice",
            product=stripe_product["product"]["id"],
            currency="aud",
            billing_scheme="per_unit",
            unit_amount=100,
            recurring=stripe.PriceRecurringArgs(
                interval="week",
                interval_count=1,
            ))
        # tiered price for the product
        price_stripe_index_price_price1 = stripe.Price("priceStripeIndex/pricePrice1",
            product=stripe_product["product"]["id"],
            currency="aud",
            billing_scheme="tiered",
            tiers_mode="graduated",
            tiers=[
                stripe.PriceTierArgs(
                    up_to=10,
                    unit_amount=0,
                ),
                stripe.PriceTierArgs(
                    up_to=100,
                    unit_amount=300,
                ),
                stripe.PriceTierArgs(
                    up_to=-1,
                    unit_amount_decimal=100.5,
                ),
            ],
            recurring=stripe.PriceRecurringArgs(
                interval="week",
                aggregate_usage="sum",
                interval_count=2,
                usage_type="metered",
            ))
        ```
        ## Note on updating prices

        Once created, you can update the `active`, `metadata`, `nickname`, `lookup_key`, `tax_behaviour` (only if unspecified)
        and `transfer_lookup_key` attributes.

        Other attribute edits will trigger a destroy action (archival) and creation of a new price entry.

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] active: Bool. Whether the price can be used for new purchases. Defaults to `true`.
        :param pulumi.Input[str] billing_scheme: String. Describes how to compute the price per period. Either `per_unit` or `tiered`
               . `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per
               unit in quantity (for prices with `usage_type=licensed`), or per unit of total usage (for prices
               with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as
               defined using the `tiers` and `tiers_mode` attributes.
        :param pulumi.Input[str] currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceCurrencyOptionArgs']]]] currency_options: List(Resource). Prices defined in each available currency option. For details
               of individual arguments see Currency Options.
        :param pulumi.Input[str] lookup_key: String. A lookup key used to retrieve prices dynamically from a static string.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
               storing additional information about the object in a structured format.
        :param pulumi.Input[str] nickname: String. A brief description of the price, hidden from customers.
        :param pulumi.Input[str] product: String. The ID of the product that this price will belong to.
        :param pulumi.Input[pulumi.InputType['PriceRecurringArgs']] recurring: List(Resource). The recurring components of a price such as `interval` and `usage_type`. For
               details of individual arguments see Recurring.
        :param pulumi.Input[str] tax_behaviour: String. Specifies whether the price is considered inclusive of taxes or exclusive of
               taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it
               cannot be changed, default is `unspecified`.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceTierArgs']]]] tiers: List(Resource). Each element represents a pricing tier. This parameter requires `billing_scheme`
               to be set to `tiered`. See also the documentation for `billing_scheme`. For details of individual arguments
               see Tiers.
        :param pulumi.Input[str] tiers_mode: String. Defines if the tiering price should be `graduated`
               or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per-unit price,
               in `graduated` tiering pricing can successively change as the quantity grows.
        :param pulumi.Input[bool] transfer_lookup_key: Bool. If set to `true`, will atomically remove the lookup key from the existing
               price, and assign it to this price.
        :param pulumi.Input[pulumi.InputType['PriceTransformQuantityArgs']] transform_quantity: List(Resource). Apply a transformation to the reported usage or set quantity before
               computing the billed price. Cannot be combined with `tiers`. For details of individual arguments
               see Transform Quantity.
        :param pulumi.Input[int] unit_amount: Int. A positive integer in cents (or `-1` for a free
               price) representing how much to charge.
        :param pulumi.Input[float] unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: PriceArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        With this resource, you can create a price - [Stripe API price documentation](https://stripe.com/docs/api/prices).

        Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of
        products. Products help you track inventory or provisioning, and prices help you track payment terms.

        Different physical goods or levels of service should be represented by products, and pricing options should be
        represented by prices. This approach lets you change prices without having to change your provisioning scheme.

        For example, you might have a single "gold" product that has prices for $10/month, $100/year, and €9 once.

        > Removal of the price isn't supported through the Stripe SDK. The best practice, which this provider follows,
        is to archive the price by marking it as inactive on destroy, which indicates that the price is no longer
        available for purchase.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_stripe as stripe

        # basic price for the product
        price_price = stripe.Price("pricePrice",
            product=stripe_product["product"]["id"],
            currency="aud",
            unit_amount=100)
        # basic free price for the product
        price_index_price_price = stripe.Price("priceIndex/pricePrice",
            product=stripe_product["product"]["id"],
            currency="aud",
            unit_amount=-1)
        # recurring price for the product
        price_stripe_index_price_price = stripe.Price("priceStripeIndex/pricePrice",
            product=stripe_product["product"]["id"],
            currency="aud",
            billing_scheme="per_unit",
            unit_amount=100,
            recurring=stripe.PriceRecurringArgs(
                interval="week",
                interval_count=1,
            ))
        # tiered price for the product
        price_stripe_index_price_price1 = stripe.Price("priceStripeIndex/pricePrice1",
            product=stripe_product["product"]["id"],
            currency="aud",
            billing_scheme="tiered",
            tiers_mode="graduated",
            tiers=[
                stripe.PriceTierArgs(
                    up_to=10,
                    unit_amount=0,
                ),
                stripe.PriceTierArgs(
                    up_to=100,
                    unit_amount=300,
                ),
                stripe.PriceTierArgs(
                    up_to=-1,
                    unit_amount_decimal=100.5,
                ),
            ],
            recurring=stripe.PriceRecurringArgs(
                interval="week",
                aggregate_usage="sum",
                interval_count=2,
                usage_type="metered",
            ))
        ```
        ## Note on updating prices

        Once created, you can update the `active`, `metadata`, `nickname`, `lookup_key`, `tax_behaviour` (only if unspecified)
        and `transfer_lookup_key` attributes.

        Other attribute edits will trigger a destroy action (archival) and creation of a new price entry.

        :param str resource_name: The name of the resource.
        :param PriceArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(PriceArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 active: Optional[pulumi.Input[bool]] = None,
                 billing_scheme: Optional[pulumi.Input[str]] = None,
                 currency: Optional[pulumi.Input[str]] = None,
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceCurrencyOptionArgs']]]]] = None,
                 lookup_key: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 nickname: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 recurring: Optional[pulumi.Input[pulumi.InputType['PriceRecurringArgs']]] = None,
                 tax_behaviour: Optional[pulumi.Input[str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceTierArgs']]]]] = None,
                 tiers_mode: Optional[pulumi.Input[str]] = None,
                 transfer_lookup_key: Optional[pulumi.Input[bool]] = None,
                 transform_quantity: Optional[pulumi.Input[pulumi.InputType['PriceTransformQuantityArgs']]] = None,
                 unit_amount: Optional[pulumi.Input[int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[float]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = PriceArgs.__new__(PriceArgs)

            __props__.__dict__["active"] = active
            __props__.__dict__["billing_scheme"] = billing_scheme
            if currency is None and not opts.urn:
                raise TypeError("Missing required property 'currency'")
            __props__.__dict__["currency"] = currency
            __props__.__dict__["currency_options"] = currency_options
            __props__.__dict__["lookup_key"] = lookup_key
            __props__.__dict__["metadata"] = metadata
            __props__.__dict__["nickname"] = nickname
            if product is None and not opts.urn:
                raise TypeError("Missing required property 'product'")
            __props__.__dict__["product"] = product
            __props__.__dict__["recurring"] = recurring
            __props__.__dict__["tax_behaviour"] = tax_behaviour
            __props__.__dict__["tiers"] = tiers
            __props__.__dict__["tiers_mode"] = tiers_mode
            __props__.__dict__["transfer_lookup_key"] = transfer_lookup_key
            __props__.__dict__["transform_quantity"] = transform_quantity
            __props__.__dict__["unit_amount"] = unit_amount
            __props__.__dict__["unit_amount_decimal"] = unit_amount_decimal
            __props__.__dict__["type"] = None
        super(Price, __self__).__init__(
            'stripe:index/price:Price',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            active: Optional[pulumi.Input[bool]] = None,
            billing_scheme: Optional[pulumi.Input[str]] = None,
            currency: Optional[pulumi.Input[str]] = None,
            currency_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceCurrencyOptionArgs']]]]] = None,
            lookup_key: Optional[pulumi.Input[str]] = None,
            metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            nickname: Optional[pulumi.Input[str]] = None,
            product: Optional[pulumi.Input[str]] = None,
            recurring: Optional[pulumi.Input[pulumi.InputType['PriceRecurringArgs']]] = None,
            tax_behaviour: Optional[pulumi.Input[str]] = None,
            tiers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceTierArgs']]]]] = None,
            tiers_mode: Optional[pulumi.Input[str]] = None,
            transfer_lookup_key: Optional[pulumi.Input[bool]] = None,
            transform_quantity: Optional[pulumi.Input[pulumi.InputType['PriceTransformQuantityArgs']]] = None,
            type: Optional[pulumi.Input[str]] = None,
            unit_amount: Optional[pulumi.Input[int]] = None,
            unit_amount_decimal: Optional[pulumi.Input[float]] = None) -> 'Price':
        """
        Get an existing Price resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] active: Bool. Whether the price can be used for new purchases. Defaults to `true`.
        :param pulumi.Input[str] billing_scheme: String. Describes how to compute the price per period. Either `per_unit` or `tiered`
               . `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per
               unit in quantity (for prices with `usage_type=licensed`), or per unit of total usage (for prices
               with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as
               defined using the `tiers` and `tiers_mode` attributes.
        :param pulumi.Input[str] currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceCurrencyOptionArgs']]]] currency_options: List(Resource). Prices defined in each available currency option. For details
               of individual arguments see Currency Options.
        :param pulumi.Input[str] lookup_key: String. A lookup key used to retrieve prices dynamically from a static string.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
               storing additional information about the object in a structured format.
        :param pulumi.Input[str] nickname: String. A brief description of the price, hidden from customers.
        :param pulumi.Input[str] product: String. The ID of the product that this price will belong to.
        :param pulumi.Input[pulumi.InputType['PriceRecurringArgs']] recurring: List(Resource). The recurring components of a price such as `interval` and `usage_type`. For
               details of individual arguments see Recurring.
        :param pulumi.Input[str] tax_behaviour: String. Specifies whether the price is considered inclusive of taxes or exclusive of
               taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it
               cannot be changed, default is `unspecified`.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PriceTierArgs']]]] tiers: List(Resource). Each element represents a pricing tier. This parameter requires `billing_scheme`
               to be set to `tiered`. See also the documentation for `billing_scheme`. For details of individual arguments
               see Tiers.
        :param pulumi.Input[str] tiers_mode: String. Defines if the tiering price should be `graduated`
               or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per-unit price,
               in `graduated` tiering pricing can successively change as the quantity grows.
        :param pulumi.Input[bool] transfer_lookup_key: Bool. If set to `true`, will atomically remove the lookup key from the existing
               price, and assign it to this price.
        :param pulumi.Input[pulumi.InputType['PriceTransformQuantityArgs']] transform_quantity: List(Resource). Apply a transformation to the reported usage or set quantity before
               computing the billed price. Cannot be combined with `tiers`. For details of individual arguments
               see Transform Quantity.
        :param pulumi.Input[str] type: String. One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a
               recurring (subscription) purchase.
        :param pulumi.Input[int] unit_amount: Int. A positive integer in cents (or `-1` for a free
               price) representing how much to charge.
        :param pulumi.Input[float] unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _PriceState.__new__(_PriceState)

        __props__.__dict__["active"] = active
        __props__.__dict__["billing_scheme"] = billing_scheme
        __props__.__dict__["currency"] = currency
        __props__.__dict__["currency_options"] = currency_options
        __props__.__dict__["lookup_key"] = lookup_key
        __props__.__dict__["metadata"] = metadata
        __props__.__dict__["nickname"] = nickname
        __props__.__dict__["product"] = product
        __props__.__dict__["recurring"] = recurring
        __props__.__dict__["tax_behaviour"] = tax_behaviour
        __props__.__dict__["tiers"] = tiers
        __props__.__dict__["tiers_mode"] = tiers_mode
        __props__.__dict__["transfer_lookup_key"] = transfer_lookup_key
        __props__.__dict__["transform_quantity"] = transform_quantity
        __props__.__dict__["type"] = type
        __props__.__dict__["unit_amount"] = unit_amount
        __props__.__dict__["unit_amount_decimal"] = unit_amount_decimal
        return Price(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def active(self) -> pulumi.Output[Optional[bool]]:
        """
        Bool. Whether the price can be used for new purchases. Defaults to `true`.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="billingScheme")
    def billing_scheme(self) -> pulumi.Output[str]:
        """
        String. Describes how to compute the price per period. Either `per_unit` or `tiered`
        . `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per
        unit in quantity (for prices with `usage_type=licensed`), or per unit of total usage (for prices
        with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as
        defined using the `tiers` and `tiers_mode` attributes.
        """
        return pulumi.get(self, "billing_scheme")

    @property
    @pulumi.getter
    def currency(self) -> pulumi.Output[str]:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> pulumi.Output[Optional[Sequence['outputs.PriceCurrencyOption']]]:
        """
        List(Resource). Prices defined in each available currency option. For details
        of individual arguments see Currency Options.
        """
        return pulumi.get(self, "currency_options")

    @property
    @pulumi.getter(name="lookupKey")
    def lookup_key(self) -> pulumi.Output[Optional[str]]:
        """
        String. A lookup key used to retrieve prices dynamically from a static string.
        """
        return pulumi.get(self, "lookup_key")

    @property
    @pulumi.getter
    def metadata(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
        storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def nickname(self) -> pulumi.Output[Optional[str]]:
        """
        String. A brief description of the price, hidden from customers.
        """
        return pulumi.get(self, "nickname")

    @property
    @pulumi.getter
    def product(self) -> pulumi.Output[str]:
        """
        String. The ID of the product that this price will belong to.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def recurring(self) -> pulumi.Output[Optional['outputs.PriceRecurring']]:
        """
        List(Resource). The recurring components of a price such as `interval` and `usage_type`. For
        details of individual arguments see Recurring.
        """
        return pulumi.get(self, "recurring")

    @property
    @pulumi.getter(name="taxBehaviour")
    def tax_behaviour(self) -> pulumi.Output[Optional[str]]:
        """
        String. Specifies whether the price is considered inclusive of taxes or exclusive of
        taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it
        cannot be changed, default is `unspecified`.
        """
        return pulumi.get(self, "tax_behaviour")

    @property
    @pulumi.getter
    def tiers(self) -> pulumi.Output[Optional[Sequence['outputs.PriceTier']]]:
        """
        List(Resource). Each element represents a pricing tier. This parameter requires `billing_scheme`
        to be set to `tiered`. See also the documentation for `billing_scheme`. For details of individual arguments
        see Tiers.
        """
        return pulumi.get(self, "tiers")

    @property
    @pulumi.getter(name="tiersMode")
    def tiers_mode(self) -> pulumi.Output[Optional[str]]:
        """
        String. Defines if the tiering price should be `graduated`
        or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per-unit price,
        in `graduated` tiering pricing can successively change as the quantity grows.
        """
        return pulumi.get(self, "tiers_mode")

    @property
    @pulumi.getter(name="transferLookupKey")
    def transfer_lookup_key(self) -> pulumi.Output[Optional[bool]]:
        """
        Bool. If set to `true`, will atomically remove the lookup key from the existing
        price, and assign it to this price.
        """
        return pulumi.get(self, "transfer_lookup_key")

    @property
    @pulumi.getter(name="transformQuantity")
    def transform_quantity(self) -> pulumi.Output[Optional['outputs.PriceTransformQuantity']]:
        """
        List(Resource). Apply a transformation to the reported usage or set quantity before
        computing the billed price. Cannot be combined with `tiers`. For details of individual arguments
        see Transform Quantity.
        """
        return pulumi.get(self, "transform_quantity")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        """
        String. One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a
        recurring (subscription) purchase.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> pulumi.Output[int]:
        """
        Int. A positive integer in cents (or `-1` for a free
        price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> pulumi.Output[float]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

