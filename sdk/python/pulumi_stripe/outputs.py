# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'FileLink',
    'FileLinkData',
    'MeterCustomerMapping',
    'MeterDefaultAggregation',
    'MeterValueSettings',
    'PortalConfigurationBusinessProfile',
    'PortalConfigurationFeatures',
    'PortalConfigurationFeaturesCustomerUpdate',
    'PortalConfigurationFeaturesInvoiceHistory',
    'PortalConfigurationFeaturesPaymentMethodUpdate',
    'PortalConfigurationFeaturesSubscriptionCancel',
    'PortalConfigurationFeaturesSubscriptionCancelCancellationReason',
    'PortalConfigurationFeaturesSubscriptionUpdate',
    'PortalConfigurationFeaturesSubscriptionUpdateProduct',
    'PortalConfigurationLoginPage',
    'PriceCurrencyOption',
    'PriceCurrencyOptionCustomUnitAmount',
    'PriceCurrencyOptionTier',
    'PriceCustomUnitAmount',
    'PriceRecurring',
    'PriceTier',
    'PriceTransformQuantity',
    'PromotionCodeRestrictions',
    'ShippingRateDeliveryEstimate',
    'ShippingRateDeliveryEstimateMaximum',
    'ShippingRateDeliveryEstimateMinimum',
    'ShippingRateFixedAmount',
    'ShippingRateFixedAmountCurrencyOption',
]

@pulumi.output_type
class FileLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created: Optional[_builtins.int] = None,
                 expired: Optional[_builtins.bool] = None,
                 expires_at: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 livemode: Optional[_builtins.bool] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None,
                 object: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.int created: String. Time at which the object was created. Measured in seconds since the Unix epoch.
        :param _builtins.bool expired: Bool. Returns if the link is already expired.
        :param _builtins.int expires_at: Int. Time that the link expires.
        :param _builtins.str id: String. Unique identifier for the object.
        :param _builtins.bool livemode: Bool. Has the value `true` if the object exists in live mode or the value `false` 
               if the object exists in test mode.
        :param Mapping[str, _builtins.str] metadata: Map(String). Set of key-value pairs that you can attach to an object.
        :param _builtins.str object: String. String representing the object’s type. Objects of the same type share the same value.
        :param _builtins.str url: String. The publicly accessible URL to download the file.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if livemode is not None:
            pulumi.set(__self__, "livemode", livemode)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def created(self) -> Optional[_builtins.int]:
        """
        String. Time at which the object was created. Measured in seconds since the Unix epoch.
        """
        return pulumi.get(self, "created")

    @_builtins.property
    @pulumi.getter
    def expired(self) -> Optional[_builtins.bool]:
        """
        Bool. Returns if the link is already expired.
        """
        return pulumi.get(self, "expired")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.int]:
        """
        Int. Time that the link expires.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        String. Unique identifier for the object.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def livemode(self) -> Optional[_builtins.bool]:
        """
        Bool. Has the value `true` if the object exists in live mode or the value `false` 
        if the object exists in test mode.
        """
        return pulumi.get(self, "livemode")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[_builtins.str]:
        """
        String. String representing the object’s type. Objects of the same type share the same value.
        """
        return pulumi.get(self, "object")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        String. The publicly accessible URL to download the file.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FileLinkData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileLinkData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileLinkData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileLinkData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create: _builtins.bool,
                 expires_at: Optional[_builtins.int] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.bool create: Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        :param _builtins.int expires_at: Int. Time that the link expires.
        :param Mapping[str, _builtins.str] metadata: Map(String). Set of key-value pairs that you can attach to an object.
        """
        pulumi.set(__self__, "create", create)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def create(self) -> _builtins.bool:
        """
        Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.int]:
        """
        Int. Time that the link expires.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map(String). Set of key-value pairs that you can attach to an object.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class MeterCustomerMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventPayloadKey":
            suggest = "event_payload_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeterCustomerMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeterCustomerMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeterCustomerMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_payload_key: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str event_payload_key: String. The key in the event payload to use for customer mapping.
        :param _builtins.str type: String. The method for mapping a meter event to a customer. Must be `by_id`.
        """
        pulumi.set(__self__, "event_payload_key", event_payload_key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="eventPayloadKey")
    def event_payload_key(self) -> _builtins.str:
        """
        String. The key in the event payload to use for customer mapping.
        """
        return pulumi.get(self, "event_payload_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        String. The method for mapping a meter event to a customer. Must be `by_id`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MeterDefaultAggregation(dict):
    def __init__(__self__, *,
                 formula: _builtins.str):
        """
        :param _builtins.str formula: String. Specifies how events are aggregated. Allowed values are `count` to count the number of events and `sum` to sum each event’s value.
        """
        pulumi.set(__self__, "formula", formula)

    @_builtins.property
    @pulumi.getter
    def formula(self) -> _builtins.str:
        """
        String. Specifies how events are aggregated. Allowed values are `count` to count the number of events and `sum` to sum each event’s value.
        """
        return pulumi.get(self, "formula")


@pulumi.output_type
class MeterValueSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventPayloadKey":
            suggest = "event_payload_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeterValueSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeterValueSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeterValueSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_payload_key: _builtins.str):
        """
        :param _builtins.str event_payload_key: The key in the usage event payload to use as the value for this meter. For example, if the event payload  contains usage on a bytes_used field, then set the event_payload_key to “bytes_used”
        """
        pulumi.set(__self__, "event_payload_key", event_payload_key)

    @_builtins.property
    @pulumi.getter(name="eventPayloadKey")
    def event_payload_key(self) -> _builtins.str:
        """
        The key in the usage event payload to use as the value for this meter. For example, if the event payload  contains usage on a bytes_used field, then set the event_payload_key to “bytes_used”
        """
        return pulumi.get(self, "event_payload_key")


@pulumi.output_type
class PortalConfigurationBusinessProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privacyPolicyUrl":
            suggest = "privacy_policy_url"
        elif key == "termsOfServiceUrl":
            suggest = "terms_of_service_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationBusinessProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationBusinessProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationBusinessProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headline: Optional[_builtins.str] = None,
                 privacy_policy_url: Optional[_builtins.str] = None,
                 terms_of_service_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str headline: String. The messaging shown to customers in the portal.
        :param _builtins.str privacy_policy_url: String. A link to the business's publicly available privacy policy.
        :param _builtins.str terms_of_service_url: String. A link to the business's publicly available terms of service.
        """
        if headline is not None:
            pulumi.set(__self__, "headline", headline)
        if privacy_policy_url is not None:
            pulumi.set(__self__, "privacy_policy_url", privacy_policy_url)
        if terms_of_service_url is not None:
            pulumi.set(__self__, "terms_of_service_url", terms_of_service_url)

    @_builtins.property
    @pulumi.getter
    def headline(self) -> Optional[_builtins.str]:
        """
        String. The messaging shown to customers in the portal.
        """
        return pulumi.get(self, "headline")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyUrl")
    def privacy_policy_url(self) -> Optional[_builtins.str]:
        """
        String. A link to the business's publicly available privacy policy.
        """
        return pulumi.get(self, "privacy_policy_url")

    @_builtins.property
    @pulumi.getter(name="termsOfServiceUrl")
    def terms_of_service_url(self) -> Optional[_builtins.str]:
        """
        String. A link to the business's publicly available terms of service.
        """
        return pulumi.get(self, "terms_of_service_url")


@pulumi.output_type
class PortalConfigurationFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerUpdate":
            suggest = "customer_update"
        elif key == "invoiceHistory":
            suggest = "invoice_history"
        elif key == "paymentMethodUpdate":
            suggest = "payment_method_update"
        elif key == "subscriptionCancel":
            suggest = "subscription_cancel"
        elif key == "subscriptionUpdates":
            suggest = "subscription_updates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_update: Optional['outputs.PortalConfigurationFeaturesCustomerUpdate'] = None,
                 invoice_history: Optional['outputs.PortalConfigurationFeaturesInvoiceHistory'] = None,
                 payment_method_update: Optional['outputs.PortalConfigurationFeaturesPaymentMethodUpdate'] = None,
                 subscription_cancel: Optional['outputs.PortalConfigurationFeaturesSubscriptionCancel'] = None,
                 subscription_updates: Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdate']] = None):
        """
        :param 'PortalConfigurationFeaturesCustomerUpdateArgs' customer_update: List(Resource). Information about updating the customer details in the portal. See Customer Update.
        :param 'PortalConfigurationFeaturesInvoiceHistoryArgs' invoice_history: List(Resource). Information about showing the billing history in the portal. See Invoice History.
        :param 'PortalConfigurationFeaturesPaymentMethodUpdateArgs' payment_method_update: List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        :param 'PortalConfigurationFeaturesSubscriptionCancelArgs' subscription_cancel: List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        :param Sequence['PortalConfigurationFeaturesSubscriptionUpdateArgs'] subscription_updates: List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
        if customer_update is not None:
            pulumi.set(__self__, "customer_update", customer_update)
        if invoice_history is not None:
            pulumi.set(__self__, "invoice_history", invoice_history)
        if payment_method_update is not None:
            pulumi.set(__self__, "payment_method_update", payment_method_update)
        if subscription_cancel is not None:
            pulumi.set(__self__, "subscription_cancel", subscription_cancel)
        if subscription_updates is not None:
            pulumi.set(__self__, "subscription_updates", subscription_updates)

    @_builtins.property
    @pulumi.getter(name="customerUpdate")
    def customer_update(self) -> Optional['outputs.PortalConfigurationFeaturesCustomerUpdate']:
        """
        List(Resource). Information about updating the customer details in the portal. See Customer Update.
        """
        return pulumi.get(self, "customer_update")

    @_builtins.property
    @pulumi.getter(name="invoiceHistory")
    def invoice_history(self) -> Optional['outputs.PortalConfigurationFeaturesInvoiceHistory']:
        """
        List(Resource). Information about showing the billing history in the portal. See Invoice History.
        """
        return pulumi.get(self, "invoice_history")

    @_builtins.property
    @pulumi.getter(name="paymentMethodUpdate")
    def payment_method_update(self) -> Optional['outputs.PortalConfigurationFeaturesPaymentMethodUpdate']:
        """
        List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        """
        return pulumi.get(self, "payment_method_update")

    @_builtins.property
    @pulumi.getter(name="subscriptionCancel")
    def subscription_cancel(self) -> Optional['outputs.PortalConfigurationFeaturesSubscriptionCancel']:
        """
        List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        """
        return pulumi.get(self, "subscription_cancel")

    @_builtins.property
    @pulumi.getter(name="subscriptionUpdates")
    def subscription_updates(self) -> Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdate']]:
        """
        List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
        return pulumi.get(self, "subscription_updates")


@pulumi.output_type
class PortalConfigurationFeaturesCustomerUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedUpdates":
            suggest = "allowed_updates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesCustomerUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesCustomerUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesCustomerUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 allowed_updates: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enabled: Whether the feature is enabled.
        :param Sequence[_builtins.str] allowed_updates: The types of customer updates that are supported. When empty, customers are not updatable.
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowed_updates is not None:
            pulumi.set(__self__, "allowed_updates", allowed_updates)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="allowedUpdates")
    def allowed_updates(self) -> Optional[Sequence[_builtins.str]]:
        """
        The types of customer updates that are supported. When empty, customers are not updatable.
        """
        return pulumi.get(self, "allowed_updates")


@pulumi.output_type
class PortalConfigurationFeaturesInvoiceHistory(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PortalConfigurationFeaturesPaymentMethodUpdate(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionCancel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cancellationReason":
            suggest = "cancellation_reason"
        elif key == "prorationBehavior":
            suggest = "proration_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesSubscriptionCancel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesSubscriptionCancel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesSubscriptionCancel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 cancellation_reason: Optional['outputs.PortalConfigurationFeaturesSubscriptionCancelCancellationReason'] = None,
                 mode: Optional[_builtins.str] = None,
                 proration_behavior: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Whether the feature is enabled.
        :param 'PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs' cancellation_reason: Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        :param _builtins.str mode: Whether to cancel subscriptions immediately or at the end of the billing period.
        :param _builtins.str proration_behavior: Whether to create prorations when canceling subscriptions.
        """
        pulumi.set(__self__, "enabled", enabled)
        if cancellation_reason is not None:
            pulumi.set(__self__, "cancellation_reason", cancellation_reason)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="cancellationReason")
    def cancellation_reason(self) -> Optional['outputs.PortalConfigurationFeaturesSubscriptionCancelCancellationReason']:
        """
        Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        """
        return pulumi.get(self, "cancellation_reason")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Whether to cancel subscriptions immediately or at the end of the billing period.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[_builtins.str]:
        """
        Whether to create prorations when canceling subscriptions.
        """
        return pulumi.get(self, "proration_behavior")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionCancelCancellationReason(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 options: Sequence[_builtins.str]):
        """
        :param _builtins.bool enabled: Bool. Whether the feature is enabled.
        :param Sequence[_builtins.str] options: List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Sequence[_builtins.str]:
        """
        List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultAllowedUpdates":
            suggest = "default_allowed_updates"
        elif key == "prorationBehavior":
            suggest = "proration_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesSubscriptionUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesSubscriptionUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesSubscriptionUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_allowed_updates: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 products: Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdateProduct'],
                 proration_behavior: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] default_allowed_updates: The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        :param _builtins.bool enabled: Whether the feature is enabled.
        :param Sequence['PortalConfigurationFeaturesSubscriptionUpdateProductArgs'] products: The list of products that support subscription updates.
        :param _builtins.str proration_behavior: Determines how to handle prorations resulting from subscription updates
        """
        pulumi.set(__self__, "default_allowed_updates", default_allowed_updates)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "products", products)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @_builtins.property
    @pulumi.getter(name="defaultAllowedUpdates")
    def default_allowed_updates(self) -> Sequence[_builtins.str]:
        """
        The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        """
        return pulumi.get(self, "default_allowed_updates")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def products(self) -> Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdateProduct']:
        """
        The list of products that support subscription updates.
        """
        return pulumi.get(self, "products")

    @_builtins.property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[_builtins.str]:
        """
        Determines how to handle prorations resulting from subscription updates
        """
        return pulumi.get(self, "proration_behavior")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionUpdateProduct(dict):
    def __init__(__self__, *,
                 prices: Sequence[_builtins.str],
                 product: _builtins.str):
        """
        :param Sequence[_builtins.str] prices: List(String). The list of price IDs for the product that a subscription can be updated to.
        :param _builtins.str product: String. The product id.
        """
        pulumi.set(__self__, "prices", prices)
        pulumi.set(__self__, "product", product)

    @_builtins.property
    @pulumi.getter
    def prices(self) -> Sequence[_builtins.str]:
        """
        List(String). The list of price IDs for the product that a subscription can be updated to.
        """
        return pulumi.get(self, "prices")

    @_builtins.property
    @pulumi.getter
    def product(self) -> _builtins.str:
        """
        String. The product id.
        """
        return pulumi.get(self, "product")


@pulumi.output_type
class PortalConfigurationLoginPage(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        :param _builtins.str url: A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PriceCurrencyOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customUnitAmount":
            suggest = "custom_unit_amount"
        elif key == "taxBehavior":
            suggest = "tax_behavior"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceCurrencyOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceCurrencyOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceCurrencyOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency: _builtins.str,
                 custom_unit_amount: Optional['outputs.PriceCurrencyOptionCustomUnitAmount'] = None,
                 tax_behavior: Optional[_builtins.str] = None,
                 tiers: Optional[Sequence['outputs.PriceCurrencyOptionTier']] = None,
                 unit_amount: Optional[_builtins.int] = None,
                 unit_amount_decimal: Optional[_builtins.float] = None):
        """
        :param _builtins.str currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param 'PriceCurrencyOptionCustomUnitAmountArgs' custom_unit_amount: List(Resource). When set,
               provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
               See details in Custom Unit Amount.
        :param _builtins.str tax_behavior: String. Only required if a default tax behavior was not provided in the Stripe Tax settings.
               Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
               One of `inclusive`, `exclusive`, or `unspecified`.
               Once specified as either inclusive or exclusive, it cannot be changed.
        :param Sequence['PriceCurrencyOptionTierArgs'] tiers: List(Resource). Each element represents a pricing tier.
               This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
               the same fields as the root tiers block
        :param _builtins.int unit_amount: Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param _builtins.float unit_amount_decimal: Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
               decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        pulumi.set(__self__, "currency", currency)
        if custom_unit_amount is not None:
            pulumi.set(__self__, "custom_unit_amount", custom_unit_amount)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> _builtins.str:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @_builtins.property
    @pulumi.getter(name="customUnitAmount")
    def custom_unit_amount(self) -> Optional['outputs.PriceCurrencyOptionCustomUnitAmount']:
        """
        List(Resource). When set,
        provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
        See details in Custom Unit Amount.
        """
        return pulumi.get(self, "custom_unit_amount")

    @_builtins.property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[_builtins.str]:
        """
        String. Only required if a default tax behavior was not provided in the Stripe Tax settings.
        Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
        One of `inclusive`, `exclusive`, or `unspecified`.
        Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behavior")

    @_builtins.property
    @pulumi.getter
    def tiers(self) -> Optional[Sequence['outputs.PriceCurrencyOptionTier']]:
        """
        List(Resource). Each element represents a pricing tier.
        This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
        the same fields as the root tiers block
        """
        return pulumi.get(self, "tiers")

    @_builtins.property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[_builtins.int]:
        """
        Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @_builtins.property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[_builtins.float]:
        """
        Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
        decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")


@pulumi.output_type
class PriceCurrencyOptionCustomUnitAmount(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 maximum: Optional[_builtins.int] = None,
                 minimum: Optional[_builtins.int] = None,
                 preset: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        :param _builtins.int maximum: Int. The maximum unit amount the customer can specify for this item.
        :param _builtins.int minimum: Int. The minimum unit amount the customer can specify for this item.
               Must be at least the minimum charge amount.
        :param _builtins.int preset: Int. The starting unit amount which can be updated by the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.int]:
        """
        Int. The maximum unit amount the customer can specify for this item.
        """
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.int]:
        """
        Int. The minimum unit amount the customer can specify for this item.
        Must be at least the minimum charge amount.
        """
        return pulumi.get(self, "minimum")

    @_builtins.property
    @pulumi.getter
    def preset(self) -> Optional[_builtins.int]:
        """
        Int. The starting unit amount which can be updated by the customer.
        """
        return pulumi.get(self, "preset")


@pulumi.output_type
class PriceCurrencyOptionTier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flatAmount":
            suggest = "flat_amount"
        elif key == "flatAmountDecimal":
            suggest = "flat_amount_decimal"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"
        elif key == "upTo":
            suggest = "up_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceCurrencyOptionTier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceCurrencyOptionTier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceCurrencyOptionTier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flat_amount: Optional[_builtins.int] = None,
                 flat_amount_decimal: Optional[_builtins.float] = None,
                 unit_amount: Optional[_builtins.int] = None,
                 unit_amount_decimal: Optional[_builtins.float] = None,
                 up_to: Optional[_builtins.int] = None):
        """
        :param _builtins.int flat_amount: Int. The flat billing amount for an entire tier, regardless of the number of units in the
               tier.
        :param _builtins.float flat_amount_decimal: Float. Same as `flat_amount`, but accepts a decimal value representing an integer
               in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        :param _builtins.int unit_amount: Int. The per-unit billing amount for each individual unit for which this tier applies.
        :param _builtins.float unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        :param _builtins.int up_to: Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
               previous tier adding one. Use `-1` to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @_builtins.property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[_builtins.int]:
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        return pulumi.get(self, "flat_amount")

    @_builtins.property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[_builtins.float]:
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @_builtins.property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[_builtins.int]:
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @_builtins.property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[_builtins.float]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @_builtins.property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[_builtins.int]:
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
        return pulumi.get(self, "up_to")


@pulumi.output_type
class PriceCustomUnitAmount(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 maximum: Optional[_builtins.int] = None,
                 minimum: Optional[_builtins.int] = None,
                 preset: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        :param _builtins.int maximum: Int. The maximum unit amount the customer can specify for this item.
        :param _builtins.int minimum: Int. The minimum unit amount the customer can specify for this item.
               Must be at least the minimum charge amount.
        :param _builtins.int preset: Int. The starting unit amount which can be updated by the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.int]:
        """
        Int. The maximum unit amount the customer can specify for this item.
        """
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.int]:
        """
        Int. The minimum unit amount the customer can specify for this item.
        Must be at least the minimum charge amount.
        """
        return pulumi.get(self, "minimum")

    @_builtins.property
    @pulumi.getter
    def preset(self) -> Optional[_builtins.int]:
        """
        Int. The starting unit amount which can be updated by the customer.
        """
        return pulumi.get(self, "preset")


@pulumi.output_type
class PriceRecurring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateUsage":
            suggest = "aggregate_usage"
        elif key == "intervalCount":
            suggest = "interval_count"
        elif key == "usageType":
            suggest = "usage_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceRecurring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceRecurring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceRecurring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: _builtins.str,
                 aggregate_usage: Optional[_builtins.str] = None,
                 interval_count: Optional[_builtins.int] = None,
                 meter: Optional[_builtins.str] = None,
                 usage_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str interval: String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        :param _builtins.str aggregate_usage: String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
               Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
               record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
               which uses the usage record with the maximum reported usage during a period.
        :param _builtins.int interval_count: Int. This parameter is (Required) when interval value is set. The number of intervals between subscription billings. For
               example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
               12 months, or 52 weeks).
        :param _builtins.str meter: String. The meter tracking the usage of a metered price.
        :param _builtins.str usage_type: String. Configures how the quantity per period should be determined. Can be either `metered`
               or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
               the total usage based on usage records. Defaults to `licensed`.
        """
        pulumi.set(__self__, "interval", interval)
        if aggregate_usage is not None:
            pulumi.set(__self__, "aggregate_usage", aggregate_usage)
        if interval_count is not None:
            pulumi.set(__self__, "interval_count", interval_count)
        if meter is not None:
            pulumi.set(__self__, "meter", meter)
        if usage_type is not None:
            pulumi.set(__self__, "usage_type", usage_type)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="aggregateUsage")
    def aggregate_usage(self) -> Optional[_builtins.str]:
        """
        String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
        Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
        record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
        which uses the usage record with the maximum reported usage during a period.
        """
        return pulumi.get(self, "aggregate_usage")

    @_builtins.property
    @pulumi.getter(name="intervalCount")
    def interval_count(self) -> Optional[_builtins.int]:
        """
        Int. This parameter is (Required) when interval value is set. The number of intervals between subscription billings. For
        example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
        12 months, or 52 weeks).
        """
        return pulumi.get(self, "interval_count")

    @_builtins.property
    @pulumi.getter
    def meter(self) -> Optional[_builtins.str]:
        """
        String. The meter tracking the usage of a metered price.
        """
        return pulumi.get(self, "meter")

    @_builtins.property
    @pulumi.getter(name="usageType")
    def usage_type(self) -> Optional[_builtins.str]:
        """
        String. Configures how the quantity per period should be determined. Can be either `metered`
        or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
        the total usage based on usage records. Defaults to `licensed`.
        """
        return pulumi.get(self, "usage_type")


@pulumi.output_type
class PriceTier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flatAmount":
            suggest = "flat_amount"
        elif key == "flatAmountDecimal":
            suggest = "flat_amount_decimal"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"
        elif key == "upTo":
            suggest = "up_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceTier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceTier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceTier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flat_amount: Optional[_builtins.int] = None,
                 flat_amount_decimal: Optional[_builtins.float] = None,
                 unit_amount: Optional[_builtins.int] = None,
                 unit_amount_decimal: Optional[_builtins.float] = None,
                 up_to: Optional[_builtins.int] = None):
        """
        :param _builtins.int flat_amount: Int. The flat billing amount for an entire tier, regardless of the number of units in the
               tier.
        :param _builtins.float flat_amount_decimal: Float. Same as `flat_amount`, but accepts a decimal value representing an integer
               in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        :param _builtins.int unit_amount: Int. The per-unit billing amount for each individual unit for which this tier applies.
        :param _builtins.float unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        :param _builtins.int up_to: Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
               previous tier adding one. Use `-1` to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @_builtins.property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[_builtins.int]:
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        return pulumi.get(self, "flat_amount")

    @_builtins.property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[_builtins.float]:
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @_builtins.property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[_builtins.int]:
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @_builtins.property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[_builtins.float]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @_builtins.property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[_builtins.int]:
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
        return pulumi.get(self, "up_to")


@pulumi.output_type
class PriceTransformQuantity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "divideBy":
            suggest = "divide_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceTransformQuantity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceTransformQuantity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceTransformQuantity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 divide_by: _builtins.int,
                 round: _builtins.str):
        """
        :param _builtins.int divide_by: Int. Divide usage by this number.
        :param _builtins.str round: String. After division, either round the result `up` or `down`.
        """
        pulumi.set(__self__, "divide_by", divide_by)
        pulumi.set(__self__, "round", round)

    @_builtins.property
    @pulumi.getter(name="divideBy")
    def divide_by(self) -> _builtins.int:
        """
        Int. Divide usage by this number.
        """
        return pulumi.get(self, "divide_by")

    @_builtins.property
    @pulumi.getter
    def round(self) -> _builtins.str:
        """
        String. After division, either round the result `up` or `down`.
        """
        return pulumi.get(self, "round")


@pulumi.output_type
class PromotionCodeRestrictions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstTimeTransaction":
            suggest = "first_time_transaction"
        elif key == "minimumAmount":
            suggest = "minimum_amount"
        elif key == "minimumAmountCurrency":
            suggest = "minimum_amount_currency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromotionCodeRestrictions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromotionCodeRestrictions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromotionCodeRestrictions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 first_time_transaction: _builtins.bool,
                 minimum_amount: Optional[_builtins.int] = None,
                 minimum_amount_currency: Optional[_builtins.str] = None):
        """
        :param _builtins.bool first_time_transaction: Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        :param _builtins.int minimum_amount: Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        :param _builtins.str minimum_amount_currency: String. Three-letter ISO code for `minimum_amount`.
        """
        pulumi.set(__self__, "first_time_transaction", first_time_transaction)
        if minimum_amount is not None:
            pulumi.set(__self__, "minimum_amount", minimum_amount)
        if minimum_amount_currency is not None:
            pulumi.set(__self__, "minimum_amount_currency", minimum_amount_currency)

    @_builtins.property
    @pulumi.getter(name="firstTimeTransaction")
    def first_time_transaction(self) -> _builtins.bool:
        """
        Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        """
        return pulumi.get(self, "first_time_transaction")

    @_builtins.property
    @pulumi.getter(name="minimumAmount")
    def minimum_amount(self) -> Optional[_builtins.int]:
        """
        Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        """
        return pulumi.get(self, "minimum_amount")

    @_builtins.property
    @pulumi.getter(name="minimumAmountCurrency")
    def minimum_amount_currency(self) -> Optional[_builtins.str]:
        """
        String. Three-letter ISO code for `minimum_amount`.
        """
        return pulumi.get(self, "minimum_amount_currency")


@pulumi.output_type
class ShippingRateDeliveryEstimate(dict):
    def __init__(__self__, *,
                 maximum: Optional['outputs.ShippingRateDeliveryEstimateMaximum'] = None,
                 minimum: Optional['outputs.ShippingRateDeliveryEstimateMinimum'] = None):
        """
        :param 'ShippingRateDeliveryEstimateMaximumArgs' maximum: List(Resource. The upper bound of the estimated range.
               Please see Delivery Estimate Definition.
        :param 'ShippingRateDeliveryEstimateMinimumArgs' minimum: List(Resource). The lower bound of the estimated range. 
               Please see Delivery Estimate Definition.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional['outputs.ShippingRateDeliveryEstimateMaximum']:
        """
        List(Resource. The upper bound of the estimated range.
        Please see Delivery Estimate Definition.
        """
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional['outputs.ShippingRateDeliveryEstimateMinimum']:
        """
        List(Resource). The lower bound of the estimated range. 
        Please see Delivery Estimate Definition.
        """
        return pulumi.get(self, "minimum")


@pulumi.output_type
class ShippingRateDeliveryEstimateMaximum(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.str unit: The upper bound of the estimated range. If empty, represents no lower bound.
        :param _builtins.int value: Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The upper bound of the estimated range. If empty, represents no lower bound.
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Must be greater than 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ShippingRateDeliveryEstimateMinimum(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.str unit: The lower bound of the estimated range. If empty, represents no lower bound.
        :param _builtins.int value: Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The lower bound of the estimated range. If empty, represents no lower bound.
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Must be greater than 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ShippingRateFixedAmount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currencyOptions":
            suggest = "currency_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingRateFixedAmount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingRateFixedAmount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingRateFixedAmount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: _builtins.int,
                 currency: _builtins.str,
                 currency_options: Optional[Sequence['outputs.ShippingRateFixedAmountCurrencyOption']] = None):
        """
        :param _builtins.int amount: Int. A non-negative integer in cents representing how much to charge.
        :param _builtins.str currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param Sequence['ShippingRateFixedAmountCurrencyOptionArgs'] currency_options: List(Resource). Please see argument details Currency Option
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> _builtins.int:
        """
        Int. A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def currency(self) -> _builtins.str:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @_builtins.property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[Sequence['outputs.ShippingRateFixedAmountCurrencyOption']]:
        """
        List(Resource). Please see argument details Currency Option
        """
        return pulumi.get(self, "currency_options")


@pulumi.output_type
class ShippingRateFixedAmountCurrencyOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taxBehavior":
            suggest = "tax_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingRateFixedAmountCurrencyOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingRateFixedAmountCurrencyOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingRateFixedAmountCurrencyOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: _builtins.int,
                 currency: _builtins.str,
                 tax_behavior: Optional[_builtins.str] = None):
        """
        :param _builtins.int amount: Int. (Required) Int. A non-negative integer in cents representing how much to charge.
        :param _builtins.str currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param _builtins.str tax_behavior: String. Specifies whether the price is considered inclusive of taxes or exclusive of
               taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified it cannot be changed, default is `unspecified`.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> _builtins.int:
        """
        Int. (Required) Int. A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def currency(self) -> _builtins.str:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @_builtins.property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[_builtins.str]:
        """
        String. Specifies whether the price is considered inclusive of taxes or exclusive of
        taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified it cannot be changed, default is `unspecified`.
        """
        return pulumi.get(self, "tax_behavior")


